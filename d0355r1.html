<!DOCTYPE html>

<html>
<head>
	<meta charset="utf-8">
	<title>Extending &lt;chrono&gt; to Calendars and Time Zones</title>
    <style type="text/css">
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {color:#00A000}
	del {color:#A00000}
    address {text-align:right;}
    h1 {text-align:center;}
    span.comment {color:#C80000;}
    table {border-width:1px; border-color:black; border-style:solid;}
    td {border-width:1px; border-color:black; border-style:solid; padding:5px;}
	code {white-space:pre;}
	</style>
</head>
<body>

<address>
Document number: D0355R1<br/>
<br/>
<a href="mailto:howard.hinnant@gmail.com">Howard E. Hinnant</a><br/>
2016-10-12<br/>
</address>
<hr/>
<h1>Extending <code>&lt;chrono&gt;</code> to Calendars and Time Zones</h1>

<h2>Contents</h2>

<ul>
<li><a href="#Revision">Revision History</a></li>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Description">Description</a></li>
<li><a href="#Wording">Proposed Wording</a></li>
<li><a href="#Acknowledgements">Acknowledgements</a></li>
<li><a href="#References">References</a></li>
</ul>

<a name="Revision"></a><h2>Revision History</h2>

<h3>Changes since <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0355r0.html">R0</a></h3>

<ul>
<li>Tighten up <code>utc_clock::utc_to_sys</code> and <code>utc_clock::sys_to_utc</code>.</li>
<li>Eliminate <code>utc_clock::utc_to_sys</code> and <code>utc_clock::sys_to_utc</code>
in favor of free functions such as <code>to_sys_time</code> and <code>to_utc_time</code>.</li>
<li>Give <code>utc_time</code> a streaming operator.</li>
<li>Change <code>format</code> to take <code>time_point</code>s by <code>const&amp;</code>
instead of by value.</li>
<li>Add trivial default constructors to most calendar types.</li>
<li>Create %Ez & %Oz to put ':' in offset for format and parse.</li>
<li>Add %F to parse.</li>
<li>Changed parse functions to parse manipulators.</li>
<li>Excuse local_t from being a clock</li>
<li>Guarantee Unix Time.</li>
<li>Add duration stream insertion.</li>
<li>Introduce tai_clock.</li>
<li>Introduce gps_clock.</li>
</ul>

<a name="Introduction"></a><h2>Introduction</h2>

<p>
The purpose of a calendar is to give a name to each day.<sup>1</sup>  There are many
different ways this can be accomplished.  This paper proposes only the Gregorian
calendar.  However the design of this proposal is such that clients can
code other calendars and have them interoperate with <code>&lt;chrono&gt;</code>,
the civil calendar, and with time zones, all with a minimal
coupling.  For example:
</p>

<blockquote><pre>
#include "coptic.h"  // not proposed, just an example
#include &lt;chrono&gt;
#include &lt;iostream&gt;

int
main()
{
    using namespace std::chrono_literals;
    auto date = 2016y/may/29;
    cout &lt;&lt; date &lt;&lt; " is " &lt;&lt; coptic::year_month_day{date} &lt;&lt; " in the Coptic calendar\n";
    // 2016-05-29 is 1732-09-21 in the Coptic calendar
}
</pre></blockquote>

<p>
The above example creates a date in the Gregorian calendar (proposed) with the
literal <code>2016y/may/29</code>.  The meaning of this literal is without
question.  It is conventional and clearly readable.  This proposal has no
knowledge whatsoever of the Coptic calendar. However it is relatively easy to
create a Coptic calendar (which knows nothing about the Gregorian calendar),
which will convert to and from the Gregorian calendar.  This is done by
establishing a clear and simple communication channel between calendar systems
and the <code>&lt;chrono&gt;</code> library (specifically a
<code>system_clock::time_point</code> with a precision of days). 
</p>

<p>
The paper proposes:
</p>

<ol>
<li>Minimal extensions to <code>&lt;chrono&gt;</code> to support calendar and
time zone libraries.</li>
<li>A <a
href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic
Gregorian calendar</a>, hereafter referred to as the <i>civil</i> calendar.</li>
<li>A time zone library based on the
<a href="http://www.iana.org/time-zones">IANA Time Zone Database</a>.</li>
<li><code>strftime</code>-like formatting and parsing facilities with fully operational
support for fractional seconds, time zone abbreviations, and UTC offsets.</li>
<li>A <code>&lt;chrono&gt;</code> clock for computing with leap seconds which is
also supported by the <a href="http://www.iana.org/time-zones">IANA Time Zone
Database</a>.</li>
</ol>

<p>
Everything proposed herein has been fully implemented here:
</p>

<blockquote>
<a href="https://github.com/HowardHinnant/date">https://github.com/HowardHinnant/date</a>
</blockquote>

<p>
The implementation includes full documentation, and an active community of users
with positive field experience.  The implementation has been ported to Windows,
Linux, and OS X.
</p>

<p>
The API stresses:
</p>

<ul>
<li>Seamless integration with the existing <code>&lt;chrono&gt;</code> library.</li>
<li>Type safety.</li>
<li>Detection of errors at compile time.</li>
<li>Performance.</li>
<li>Ease of use.</li>
<li>Readable code.</li>
<li>No artificial restrictions on precision.</li>
</ul>

<p>
Listing "Performance" in the API design deserves a little explanation as one
usually thinks of that as an implementation issue.  Think of it this way:
</p>

<ul>
<li>
If <code>vector&lt;T&gt;::push_front(const T&amp;)</code> existed, that would
encourage inefficient code, even though it would be trivial to implement.
</li>
<li>
If <code>list&lt;T&gt;::operator[](size_type index)</code> existed, that would
encourage inefficient code, even though it would be trivial to implement (by
incrementing from <code>begin()</code> or decrementing from <code>end()</code>).
</li>
</ul>

<p>
This API makes it convenient to write efficient code, and inconvenient to write
inefficient code.  It turns out that conversion between a field type such as
<code>{year, month, day}</code> and a serial type such as
<code>{count-of-days}</code> is one of the more expensive operations when
dealing with calendrical computations. Both data structures are very useful
(just as both <code>vector</code> and <code>list</code> are very useful). So
this library puts <i>you</i> in control of when and how often that conversion
takes place, and makes it easy to avoid such conversions when not necessary.
</p>

<a name="Description"></a><h2>Description</h2>

<p>
One can create a <code>year</code> like this:
</p>

<blockquote><pre>
auto y = year{2016};
</pre></blockquote>

<p>
Just like <code>&lt;chrono&gt;</code>, type safety is taken very seriously.  The
type <code>year</code> is distinct from type <code>int</code>, just as <code>3</code>
can never mean "3 seconds", unless it is <i>explicitly</i> typed to do so:
<code>seconds{3}</code>.
</p>

<p>
And just like <code>seconds</code>, there is a year literal suffix which can help make 
your code more readable:
</p>

<blockquote><pre>
auto y = 2016y;
</pre></blockquote>

<p>
<code>year</code> is a <i>partial-calendar-type</i>.  It can be combined with
other partial-calendar-types to create a <i>full-calendar-type</i> such as
<code>year_month_day</code>. Full-calendar-types can be converted to and from
the family of <code>system_clock::time_point</code>s.  Full-calendar-types such
as <code>year_month_day</code> are time points with a precision of a day, but
they are also <i>field</i> types.  They are composed of 3 fields under the hood:
<code>year</code>, <code>month</code> and <code>day</code>.  Thus when you
construct a <code>year_month_day</code> from a <code>year</code>,
<code>month</code> and <code>day</code>, absolutely no computation takes place. 
The only thing that happens is a <code>year</code>, <code>month</code> and
<code>day</code> are stored inside the <code>year_month_day</code>.
</p>

<blockquote><pre>
year_month_day ymd1{2016y, month{5}, day{29}};
</pre></blockquote>

<p>
This is a <i>very</i> simple operation and can even be made
<code>constexpr</code> when all of the inputs are compile-time constants.  And
<i>conventional syntax</i> is available which means the exact same thing, with
the same run-time or compile-time performance.  It can make date literals much
more readable without sacrificing type safety:
</p>

<blockquote><pre>
constexpr year_month_day ymd1{2016y, month{5}, day{29}};
constexpr auto ymd2 = 2016y/may/29d;
static_assert(ymd1         == ymd2);
static_assert(ymd1.year()  == 2016y);
static_assert(ymd1.month() == may);
static_assert(ymd1.day()   == 29d);
</pre></blockquote>

<p>
<code>year_month_day</code> is a <i>very</i> simple, <i>very</i> understandable
<i>calendrical</i> data structure:
</p>

<blockquote><pre>
class year_month_day
{
    chrono::year  y_;  // exposition only
    chrono::month m_;  // exposition only
    chrono::day   d_;  // exposition only

public:
    constexpr year_month_day(const chrono::year&amp; y, const chrono::month&amp; m, const chrono::day&amp; d) noexcept;
    // ...
</pre></blockquote>

<p>
By now you should be yawning and muttering "so what?"
</p>

<p>
Now we introduce a little <code>&lt;chrono&gt;</code> infrastructure that serves
as the communication channel with simplistic calendrical data structures such as
<code>year_month_day</code>.
</p>

<blockquote><pre>
using days = duration&lt;int32_t, ratio_multiply&lt;ratio&lt;24&gt;, hours::period&gt;&gt;;
template &lt;class Duration&gt; using sys_time = time_point&lt;system_clock, Duration&gt;;
using sys_days = sys_time&lt;days&gt;;
</pre></blockquote>

<p>
<code>sys_days</code> <b>is</b> a <code>std::chrono::time_point</code>.  This
<code>time_point</code> is based on <code>system_clock</code> and has a very coarse
precision:  24 hours.  Just as <code>system_clock::time_point</code> is nothing more
than a count of microseconds (or nanoseconds, or whatever), <code>sys_days</code> is
simply a count of days since the <code>system_clock</code> epoch.  And
<code>sys_days</code> is <i>fully</i> interoperable with
<code>system_clock::time_point</code> in all of the ways normal to the
<code>&lt;chrono&gt;</code> library:
</p>

<ul>
<li><code>sys_days</code> implicitly converts to <code>system_clock::time_point</code>
with no truncation error.</li>
<li><code>system_clock::time_point</code> <i>does not</i> implicitly convert to
<code>sys_days</code> because it would involve truncation error.</li>
<li>Explicit conversion can be achieved from <code>system_clock::time_point</code> by
using the existing <code>&lt;chrono&gt;</code> facilities <code>time_point_cast</code>
or <code>floor</code>.</li>
</ul>

<blockquote><pre>
constexpr system_clock::time_point tp = sys_days{2016y/may/29d}; // Convert date to time_point
static_assert(tp.time_since_epoch() == 1'464'480'000'000'000us);
constexpr auto ymd = year_month_day{floor&lt;days&gt;(tp)};            // Convert time_point to date
static_assert(ymd == 2016y/may/29d);
</pre></blockquote>

<p>
The calendrical type <code>year_month_day</code> provides conversions to and
from <code>sys_days</code>.  This conversion is easy to do for std::lib
implementors using algorithms
<a href="http://howardhinnant.github.io/date_algorithms.html">such as these</a>.
If the committee standardizes existing practice and specifies that
<code>system_clock</code> measures
<a href="https://en.wikipedia.org/wiki/Unix_time">Unix Time</a>,
then it will be equally easy for
anyone to write their own calendar system which converts to and from
<code>sys_days</code> (e.g. the coptic example in the introduction).
</p>

<p>
This proposal actually contains a second calendar.  It is so closely related to the
civil calendar that we normally don't think of it as another calendar.  We often
refer to dates like "the 5th Sunday of May in 2016" as opposed to "the 29th of May
in 2016."  This proposal makes it so easy to build fully functional calendars that
interoperate with <code>system_clock::time_point</code>, that it is nearly trivial
to include such functionality:
</p>

<blockquote><pre>
constexpr system_clock::time_point tp = sys_days{sun[5]/may/2016}; // Convert date to time_point
static_assert(tp.time_since_epoch() == 1'464'480'000'000'000us);
constexpr auto ymd = year_month_weekday{floor&lt;days&gt;(tp)};          // Convert time_point to date
static_assert(ymd == sun[5]/may/2016);
</pre></blockquote>

<p>
The literal <code>sun[5]/may/2016</code> means "the 5th Sunday of May in 2016." 
The <i>conventional</i> syntax is remarkably readable.  Constructor syntax is
also available to do the same thing.  The type constructed is
<code>year_month_weekday</code> which does nothing but store a
<code>year</code>, <code>month</code>, <code>weekday</code>, and the number 5. 
This "auxiliary calendar" converts to and from <code>sys_days</code> just like
<code>year_month_day</code> as demonstrated above.  As such,
<code>year_month_weekday</code> will interoperate with <code>year_month_day</code>
(by bouncing off of <code>sys_days</code>) just as it will with any other calendar
that interoperates with <code>sys_days</code>:
</p>

<blockquote><pre>
static_assert(2016y/may/29d == year_month_day{sun[5]/may/2016});
</pre></blockquote>

<p>
Since <code>year_month_day</code> is so easy to convert to (or from) a
<code>time_point</code> it makes sense to convert to a <code>time_point</code> when
you need to talk about a date and time-of-day:
</p>

<blockquote><pre>
constexpr auto tp = sys_days{2016y/may/29d} + 7h + 30min; // 2016-05-29 07:30 UTC
</pre></blockquote>

<p>
The time zone is implicitly UTC because <code>system_clock</code> tracks <a
href="https://en.wikipedia.org/wiki/Unix_time">Unix Time</a> which is (a very
close approximation to) UTC.  If you need another time zone, no worries, we'll
get there.  And remember, <code>tp</code> above is a
<code>system_clock::time_point</code>, except with minutes precision.  You can
compare it with <code>system_clock::now()</code> to find out if the date is in
the past or the future.   Also note that the syntax above (like
<code>&lt;chrono&gt;</code>) is <i>precision neutral</i>.  That's because the
syntax above <b>is</b> <code>&lt;chrono&gt;</code>, except for the part
converting a calendar type into the <code>&lt;chrono&gt;</code> system.  If you
suddenly need to convert your minutes-precision time point into seconds or
milliseconds (or whatever) precision, the change is seamlessly handled by the
existing <code>&lt;chrono&gt;</code> system:
</p>

<blockquote><pre>
constexpr auto tp = sys_days{2016y/may/29d} + 7h + 30min + 6s + 153ms; // 2016-05-29 07:30:06.153 UTC
</pre></blockquote>

<p>
Simple streaming is provided:
</p>

<blockquote><pre>
cout &lt;&lt; tp &lt;&lt; '\n';  // 2016-05-29 07:30:06.153
</pre></blockquote>

<p>
But I need the time in Tokyo!
</p>

<blockquote><pre>
auto tp = sys_days{2016y/may/29d} + 7h + 30min + 6s + 153ms; // 2016-05-29 07:30:06.153 UTC
auto zt = make_zoned("Asia/Tokyo", tp);
cout &lt;&lt; zt &lt;&lt; '\n';                                          // 2016-05-29 16:30:06.153 JST
</pre></blockquote>

<p>
The helper function <code>make_zoned</code> creates a type <code>zoned_time</code> which
is templated on the duration type of <code>tp</code>.  The use of <code>make_zoned</code>
<i>deduces</i> that you desire milliseconds precision in this example.  This effectively
pairs a time zone with a time point.  In this example we pair the time zone
"Asia/Tokyo" with a <code>sys_time</code> (which is implicitly UTC).  When printed
out, you see the local time, and by default the current time zone abbreviation.  Also
by default, you see the full precision of the <code>zoned_time</code>.
</p>

<p>
Sometimes, instead of specifying the time in UTC as above, it is convenient to specify
the time in terms of the local time of the time zone.  It is very easy to change the
above example to mean 7:30 JST instead of 7:30 UTC:
</p>

<blockquote><pre>
auto tp = local_days{2016y/may/29d} + 7h + 30min + 6s + 153ms; // 2016-05-29 07:30:06.153
auto zt = make_zoned("Asia/Tokyo", tp);
cout &lt;&lt; zt &lt;&lt; '\n';                                            // 2016-05-29 07:30:06.153 JST
</pre></blockquote>

<p>
The <i>only</i> change to the code is the use of <code>local_days</code> in
place of <code>sys_days</code>.  <code>local_days</code> is also a
<code>std::chrono::time_point</code> but it has no <code>clock::now()</code>
functionality.  This <code>time_point</code> is called <code>local_time</code>. 
A <code>local_time</code> can refer to <i>any</i> time zone.  In the above
example when we pair "Asia/Tokyo" with the <code>local_time</code>, the
result becomes a <code>zoned_time</code> with the local time specified by the
<code>local_time</code>.
</p>

<p>
To interoperate with time zones, calendrical types must convert to and from
<code>local_days</code> as well as <code>sys_days</code>.  The math is identical
for both conversions, so it is very easy for the calendar author to provide. 
But as seen in this example, the meaning can be quite different.
</p>

<p>
The client of the calendar library can easily use the calendar types with the
time zone library, specifying times either in the local time, or in UTC, simply
by switching between <code>local_days</code> and <code>sys_days</code>.  Here
is an example that sets up a meeting at 9am on the third Tuesday of June, 2016
in New York:
</p>

<blockquote><pre>
auto zt = make_zoned("America/New_York", local_days{tue[3]/jun/2016} + 9h);
cout &lt;&lt; zt &lt;&lt; '\n';  // 2016-06-21 09:00:00 EDT
</pre></blockquote>

<p>
Need to set up a video conference with your partners in Helsinki?
</p>

<blockquote><pre>
cout &lt;&lt; make_zoned("Europe/Helsinki", zt) &lt;&lt; '\n';
</pre></blockquote>

<p>
This converts one <code>zoned_time</code> into another <code>zoned_time</code> where
the only difference is changing from "America/New_York" to "Europe/Helsinki".  The
conversion preserves the UTC equivalent in both <code>zoned_time</code>s, and
therefore outputs:
</p>

<blockquote><pre>
2016-06-21 16:00:00 EEST
</pre></blockquote>

<p>
And if this is not the formatting you prefer, that is easily fixed too:
</p>

<blockquote><pre>
cout &lt;&lt; format("%F %H:%M %z", make_zoned("Europe/Helsinki", zt)) &lt;&lt; '\n';
// 2016-06-21 16:00 +0300
</pre></blockquote>

<p>
Or perhaps properly localized:
</p>

<blockquote><pre>
cout &lt;&lt; format(locale{"fi_FI"}, "%c", make_zoned("Europe/Helsinki", zt)) &lt;&lt; '\n';
// Ti 21 Kes 16:00:00 2016
</pre></blockquote>

<p>
Wait, slow down, this is too much information!  Let's start at the beginning.
How do I get the current time?
</p>

<blockquote><pre>
cout &lt;&lt; system_clock::now() &lt;&lt; " UTC\n";
// 2016-05-30 17:57:30.694574 UTC
</pre></blockquote>

<p>
My current local time?
</p>

<blockquote><pre>
cout &lt;&lt; make_zoned(current_zone(), system_clock::now()) &lt;&lt; '\n';
// 2016-05-30 13:57:30.694574 EDT
</pre></blockquote>

<p>
Current time in Budapest?
</p>

<blockquote><pre>
cout &lt;&lt; make_zoned("Europe/Budapest", system_clock::now()) &lt;&lt; '\n';
// 2016-05-30 19:57:30.694574 CEST
</pre></blockquote>

<p>
For more documentation about the calendar portion of this proposal, including more
details, more examples, and performance analyses, please see:
</p>

<blockquote>
<a href="http://howardhinnant.github.io/date/date.html">http://howardhinnant.github.io/date/date.html</a>
</blockquote>

<p>
For a video introduction to the calendar portion, please see:
</p>

<blockquote>
<a href="https://www.youtube.com/watch?v=tzyGjOm8AKo">https://www.youtube.com/watch?v=tzyGjOm8AKo</a>
</blockquote>

<p>
For a video introduction to the time zone portion, please see:
</p>

<blockquote>
<a href="https://www.youtube.com/watch?v=Vwd3pduVGKY">https://www.youtube.com/watch?v=Vwd3pduVGKY</a>
</blockquote>

<p>
For more documentation about the time zone portion of this proposal, including more
details, and more examples, please see:
</p>

<blockquote>
<a href="http://howardhinnant.github.io/date/tz.html">http://howardhinnant.github.io/date/tz.html</a>
</blockquote>

<p>
For more examples, some of which are written by users of this library, please see:
</p>

<blockquote>
<a href="https://github.com/HowardHinnant/date/wiki/Examples-and-Recipes">https://github.com/HowardHinnant/date/wiki/Examples-and-Recipes</a>
</blockquote>

<p>
For another example calendar which models the
<a href="https://en.wikipedia.org/wiki/ISO_week_date">ISO week-based calendar</a>,
please see:
</p>

<blockquote>
<a href="http://howardhinnant.github.io/date/iso_week.html">http://howardhinnant.github.io/date/iso_week.html</a>
</blockquote>

<a name="Wording"></a><h2>Proposed Wording</h2>

<blockquote class = note><p>
Text in grey boxes is not proposed wording.
</p></blockquote>

<blockquote class = note><p>
Insert into synopsis in 20.17.2 Header <code>&lt;chrono&gt;</code> synopsis [time.syn]:
</p></blockquote>

<blockquote><pre>
namespace std {
namespace chrono {

// ...

// duration stream insertion
template &lt;class charT, class traits, class Rep, class Period&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               const duration&lt;Rep, Period&gt;&amp; d);

// ...
// convenience typedefs
// ...
using days   = duration&lt;<i>signed integer type of at least 25 bits</i>, ratio_multiply&lt;ratio&lt;24&gt;, hours::period&gt;&gt;;
using weeks  = duration&lt;<i>signed integer type of at least 22 bits</i>, ratio_multiply&lt;ratio&lt;7&gt;, days::period&gt;&gt;;
using years  = duration&lt;<i>signed integer type of at least 17 bits</i>, ratio_multiply&lt;ratio&lt;146097, 400&gt;, days::period&gt;&gt;;
using months = duration&lt;<i>signed integer type of at least 20 bits</i>, ratio_divide&lt;years::period, ratio&lt;12&gt;&gt;&gt;;

// ...
// clocks
// ...
class utc_clock;
class tai_clock;
class gps_clock;

template &lt;class Duration&gt;
    using sys_time = time_point&lt;system_clock, Duration&gt;;
using sys_seconds  = sys_time&lt;seconds&gt;;
using sys_days     = sys_time&lt;days&gt;;

template &lt;class Duration&gt;
    using utc_time = time_point&lt;utc_clock, Duration&gt;;
using utc_seconds  = utc_time&lt;seconds&gt;;

template &lt;class Duration&gt;
    using tai_time = time_point&lt;tai_clock, Duration&gt;;
using tai_seconds  = tai_time&lt;seconds&gt;;

template &lt;class Duration&gt;
    using gps_time = time_point&lt;gps_clock, Duration&gt;;
using gps_seconds  = gps_time&lt;seconds&gt;;

template &lt;class Duration&gt;
    sys_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_sys_time(utc_time&lt;Duration&gt; t);
template &lt;class Duration&gt;
    sys_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_sys_time(tai_time&lt;Duration&gt; t);
template &lt;class Duration&gt;
    sys_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_sys_time(gps_time&lt;Duration&gt; t);

template &lt;class Duration&gt;
    utc_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_utc_time(sys_time&lt;Duration&gt; t);
template &lt;class Duration&gt;
    utc_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_utc_time(tai_time&lt;Duration&gt; t);
template &lt;class Duration&gt;
    utc_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_utc_time(gps_time&lt;Duration&gt; t);

template &lt;class Duration&gt;
    tai_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_tai_time(sys_time&lt;Duration&gt; t);
template &lt;class Duration&gt;
    tai_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_tai_time(utc_time&lt;Duration&gt; t);
template &lt;class Duration&gt;
    tai_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_tai_time(gps_time&lt;Duration&gt; t);

template &lt;class Duration&gt;
    gps_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_gps_time(sys_time&lt;Duration&gt; t);
template &lt;class Duration&gt;
    gps_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_gps_time(utc_time&lt;Duration&gt; t);
template &lt;class Duration&gt;
    gps_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    to_gps_time(tai_time&lt;Duration&gt; t);

template &lt;class charT, class traits, class Duration&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const sys_time&lt;Duration&gt;&amp; tp);
template &lt;class charT, class traits&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const sys_days&amp; dp);
template &lt;class charT, class traits, class Duration&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const utc_time&lt;Duration&gt;&amp; t);
template &lt;class charT, class traits, class Duration&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const tai_time&lt;Duration&gt;&amp; t);
template &lt;class charT, class traits, class Duration&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const gps_time&lt;Duration&gt;&amp; t);

struct local_t {};
template &lt;class Duration&gt;
    using local_time = time_point&lt;local_t, Duration&gt;;
using local_seconds  = local_time&lt;seconds&gt;;
using local_days     = local_time&lt;days&gt;;

template &lt;class charT, class traits, class Duration&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const local_time&lt;Duration&gt;&amp; tp);

// civil calendar

struct last_spec;

class day;

constexpr bool operator==(const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator!=(const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&lt; (const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&gt; (const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&lt;=(const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&gt;=(const day&amp; x, const day&amp; y) noexcept;

constexpr day  operator+(const day&amp;  x, const days&amp; y) noexcept;
constexpr day  operator+(const days&amp; x, const day&amp;  y) noexcept;
constexpr day  operator-(const day&amp;  x, const days&amp; y) noexcept;
constexpr days operator-(const day&amp;  x, const day&amp;  y) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const day&amp; d);

class month;

constexpr bool operator==(const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator!=(const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&lt; (const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&gt; (const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&lt;=(const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&gt;=(const month&amp; x, const month&amp; y) noexcept;

constexpr month  operator+(const month&amp;  x, const months&amp; y) noexcept;
constexpr month  operator+(const months&amp; x,  const month&amp; y) noexcept;
constexpr month  operator-(const month&amp;  x, const months&amp; y) noexcept;
constexpr months operator-(const month&amp;  x,  const month&amp; y) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const month&amp; m);

class year;

constexpr bool operator==(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator!=(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&lt; (const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&gt; (const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&lt;=(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&gt;=(const year&amp; x, const year&amp; y) noexcept;

constexpr year  operator+(const year&amp;  x, const years&amp; y) noexcept;
constexpr year  operator+(const years&amp; x, const year&amp;  y) noexcept;
constexpr year  operator-(const year&amp;  x, const years&amp; y) noexcept;
constexpr years operator-(const year&amp;  x, const year&amp;  y) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const year&amp; y);

class weekday;

constexpr bool operator==(const weekday&amp; x, const weekday&amp; y) noexcept;
constexpr bool operator!=(const weekday&amp; x, const weekday&amp; y) noexcept;

constexpr weekday operator+(const weekday&amp; x, const days&amp;    y) noexcept;
constexpr weekday operator+(const days&amp;    x, const weekday&amp; y) noexcept;
constexpr weekday operator-(const weekday&amp; x, const days&amp;    y) noexcept;
constexpr days    operator-(const weekday&amp; x, const weekday&amp; y) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const weekday&amp; wd);

class weekday_indexed;

constexpr bool operator==(const weekday_indexed&amp; x, const weekday_indexed&amp; y) noexcept;
constexpr bool operator!=(const weekday_indexed&amp; x, const weekday_indexed&amp; y) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const weekday_indexed&amp; wdi);

class weekday_last;

constexpr bool operator==(const weekday_last&amp; x, const weekday_last&amp; y) noexcept;
constexpr bool operator!=(const weekday_last&amp; x, const weekday_last&amp; y) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const weekday_last&amp; wdl);

class month_day;

constexpr bool operator==(const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator!=(const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&lt; (const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&gt; (const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&lt;=(const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&gt;=(const month_day&amp; x, const month_day&amp; y) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const month_day&amp; md);

class month_day_last;

constexpr bool operator==(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator!=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&lt; (const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&gt; (const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&lt;=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&gt;=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const month_day_last&amp; mdl);

class month_weekday;

constexpr bool operator==(const month_weekday&amp; x, const month_weekday&amp; y) noexcept;
constexpr bool operator!=(const month_weekday&amp; x, const month_weekday&amp; y) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const month_weekday&amp; mwd);

class month_weekday_last;

constexpr bool operator==(const month_weekday_last&amp; x, const month_weekday_last&amp; y) noexcept;
constexpr bool operator!=(const month_weekday_last&amp; x, const month_weekday_last&amp; y) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const month_weekday_last&amp; mwdl);

class year_month;

constexpr bool operator==(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator!=(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&lt; (const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&gt; (const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&lt;=(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&gt;=(const year_month&amp; x, const year_month&amp; y) noexcept;

constexpr year_month operator+(const year_month&amp; ym, const months&amp; dm) noexcept;
constexpr year_month operator+(const months&amp; dm, const year_month&amp; ym) noexcept;
constexpr year_month operator-(const year_month&amp; ym, const months&amp; dm) noexcept;
constexpr months operator-(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr year_month operator+(const year_month&amp; ym, const years&amp; dy) noexcept;
constexpr year_month operator+(const years&amp; dy, const year_month&amp; ym) noexcept;
constexpr year_month operator-(const year_month&amp; ym, const years&amp; dy) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const year_month&amp; ym);

class year_month_day;

constexpr bool operator==(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator!=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&lt; (const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&gt; (const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&lt;=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&gt;=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;

constexpr year_month_day operator+(const year_month_day&amp; ymd, const months&amp; dm) noexcept;
constexpr year_month_day operator+(const months&amp; dm, const year_month_day&amp; ymd) noexcept;
constexpr year_month_day operator+(const year_month_day&amp; ymd, const years&amp; dy) noexcept;
constexpr year_month_day operator+(const years&amp; dy, const year_month_day&amp; ymd) noexcept;
constexpr year_month_day operator-(const year_month_day&amp; ymd, const months&amp; dm) noexcept;
constexpr year_month_day operator-(const year_month_day&amp; ymd, const years&amp; dy) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const year_month_day&amp; ymd);

class year_month_day_last;

constexpr bool operator==(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator!=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&lt; (const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&gt; (const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&lt;=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&gt;=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;

constexpr year_month_day_last operator+(const year_month_day_last&amp; ymdl, const months&amp; dm) noexcept;
constexpr year_month_day_last operator+(const months&amp; dm, const year_month_day_last&amp; ymdl) noexcept;
constexpr year_month_day_last operator+(const year_month_day_last&amp; ymdl, const years&amp; dy) noexcept;
constexpr year_month_day_last operator+(const years&amp; dy, const year_month_day_last&amp; ymdl) noexcept;
constexpr year_month_day_last operator-(const year_month_day_last&amp; ymdl, const months&amp; dm) noexcept;
constexpr year_month_day_last operator-(const year_month_day_last&amp; ymdl, const years&amp; dy) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const year_month_day_last&amp; ymdl);

class year_month_weekday;

constexpr bool operator==(const year_month_weekday&amp; x, const year_month_weekday&amp; y) noexcept;
constexpr bool operator!=(const year_month_weekday&amp; x, const year_month_weekday&amp; y) noexcept;

constexpr year_month_weekday operator+(const year_month_weekday&amp; ymwd, const months&amp; dm) noexcept;
constexpr year_month_weekday operator+(const months&amp; dm, const year_month_weekday&amp; ymwd) noexcept;
constexpr year_month_weekday operator+(const year_month_weekday&amp; ymwd, const years&amp; dy) noexcept;
constexpr year_month_weekday operator+(const years&amp; dy, const year_month_weekday&amp; ymwd) noexcept;
constexpr year_month_weekday operator-(const year_month_weekday&amp; ymwd, const months&amp; dm) noexcept;
constexpr year_month_weekday operator-(const year_month_weekday&amp; ymwd, const years&amp; dy) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const year_month_weekday&amp; ymwdi);

class year_month_weekday_last;

constexpr bool operator==(const year_month_weekday_last&amp; x, const year_month_weekday_last&amp; y) noexcept;
constexpr bool operator!=(const year_month_weekday_last&amp; x, const year_month_weekday_last&amp; y) noexcept;

constexpr year_month_weekday_last operator+(const year_month_weekday_last&amp; ymwdl, const months&amp; dm) noexcept;
constexpr year_month_weekday_last operator+(const months&amp; dm, const year_month_weekday_last&amp; ymwdl) noexcept;
constexpr year_month_weekday_last operator+(const year_month_weekday_last&amp; ymwdl, const years&amp; dy) noexcept;
constexpr year_month_weekday_last operator+(const years&amp; dy, const year_month_weekday_last&amp; ymwdl) noexcept;
constexpr year_month_weekday_last operator-(const year_month_weekday_last&amp; ymwdl, const months&amp; dm) noexcept;
constexpr year_month_weekday_last operator-(const year_month_weekday_last&amp; ymwdl, const years&amp; dy) noexcept;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const year_month_weekday_last&amp; ymwdl);

// civil calendar conventional syntax operators
constexpr year_month operator/(const year&amp; y, const month&amp; m) noexcept;
constexpr year_month operator/(const year&amp; y, int   m) noexcept;
constexpr month_day operator/(const month&amp; m, const day&amp; d) noexcept;
constexpr month_day operator/(const month&amp; m, int d) noexcept;
constexpr month_day operator/(int m, const day&amp; d) noexcept;
constexpr month_day operator/(const day&amp; d, const month&amp; m) noexcept;
constexpr month_day operator/(const day&amp; d, int m) noexcept;
constexpr month_day_last operator/(const month&amp; m, last_spec) noexcept;
constexpr month_day_last operator/(int m, last_spec) noexcept;
constexpr month_day_last operator/(last_spec, const month&amp; m) noexcept;
constexpr month_day_last operator/(last_spec, int m) noexcept;
constexpr month_weekday operator/(const month&amp; m, const weekday_indexed&amp; wdi) noexcept;
constexpr month_weekday operator/(int m, const weekday_indexed&amp; wdi) noexcept;
constexpr month_weekday operator/(const weekday_indexed&amp; wdi, const month&amp; m) noexcept;
constexpr month_weekday operator/(const weekday_indexed&amp; wdi, int m) noexcept;
constexpr month_weekday_last operator/(const month&amp; m, const weekday_last&amp; wdl) noexcept;
constexpr month_weekday_last operator/(int m, const weekday_last&amp; wdl) noexcept;
constexpr month_weekday_last operator/(const weekday_last&amp; wdl, const month&amp; m) noexcept;
constexpr month_weekday_last operator/(const weekday_last&amp; wdl, int m) noexcept;
constexpr year_month_day operator/(const year_month&amp; ym, const day&amp; d) noexcept;
constexpr year_month_day operator/(const year_month&amp; ym, int d) noexcept;
constexpr year_month_day operator/(const year&amp; y, const month_day&amp; md) noexcept;
constexpr year_month_day operator/(int y, const month_day&amp; md) noexcept;
constexpr year_month_day operator/(const month_day&amp; md, const year&amp; y) noexcept;
constexpr year_month_day operator/(const month_day&amp; md, int y) noexcept;
constexpr year_month_day_last operator/(const year_month&amp; ym, last_spec) noexcept;
constexpr year_month_day_last operator/(const year&amp; y, const month_day_last&amp; mdl) noexcept;
constexpr year_month_day_last operator/(int y, const month_day_last&amp; mdl) noexcept;
constexpr year_month_day_last operator/(const month_day_last&amp; mdl, const year&amp; y) noexcept;
constexpr year_month_day_last operator/(const month_day_last&amp; mdl, int y) noexcept;
constexpr year_month_weekday operator/(const year_month&amp; ym, const weekday_indexed&amp; wdi) noexcept;
constexpr year_month_weekday operator/(const year&amp; y, const month_weekday&amp; mwd) noexcept;
constexpr year_month_weekday operator/(int y, const month_weekday&amp; mwd) noexcept;
constexpr year_month_weekday operator/(const month_weekday&amp; mwd, const year&amp; y) noexcept;
constexpr year_month_weekday operator/(const month_weekday&amp; mwd, int y) noexcept;
constexpr year_month_weekday_last operator/(const year_month&amp; ym, const weekday_last&amp; wdl) noexcept;
constexpr year_month_weekday_last operator/(const year&amp; y, const month_weekday_last&amp; mwdl) noexcept;
constexpr year_month_weekday_last operator/(int y, const month_weekday_last&amp; mwdl) noexcept;
constexpr year_month_weekday_last operator/(const month_weekday_last&amp; mwdl, const year&amp; y) noexcept;
constexpr year_month_weekday_last operator/(const month_weekday_last&amp; mwdl, int y) noexcept;

// time_of_day
enum {am = 1, pm};
template &lt;class Duration&gt; class time_of_day;
time_of_day&lt;hours&gt;
time_of_day&lt;minutes&gt;
time_of_day&lt;seconds&gt;
time_of_day&lt;duration&lt;Rep, Period&gt;&gt;

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const time_of_day&lt;hours&gt;&amp; t);

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const time_of_day&lt;minutes&gt;&amp; t);

template&lt;class charT, class traits&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const time_of_day&lt;seconds&gt;&amp; t);

template&lt;class charT, class traits, class Rep, class Period&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const time_of_day&lt;duration&lt;Rep, Period&gt;&gt;&amp; t);

template &lt;class Rep, class Period&gt;
    constexpr time_of_day&lt;duration&lt;Rep, Period&gt;&gt;
    make_time(duration&lt;Rep, Period&gt; d) noexcept;

constexpr time_of_day&lt;hours&gt;   make_time(hours h, unsigned md) noexcept;
constexpr time_of_day&lt;minutes&gt; make_time(hours h, minutes m, unsigned md) noexcept;
constexpr time_of_day&lt;seconds&gt; make_time(hours h, minutes m, seconds s, unsigned md) noexcept;

template &lt;class Rep, class Period&gt;
    constexpr time_of_day&lt;duration&lt;Rep, Period&gt;&gt;
    make_time(hours h, minutes m, seconds s, duration&lt;Rep, Period&gt; sub_s, unsigned md) noexcept;

// time zone database

struct TZ_DB;
const TZ_DB&amp; get_tzdb();
const time_zone* locate_zone(const string&amp; tz_name);
const time_zone* current_zone();

// Remote time zone database -- Needs discussion

const TZ_DB&amp; reload_tzdb();
string       remote_version();
bool         remote_download(const string&amp; version);
bool         remote_install(const string&amp; version);

// exception classes
class nonexistent_local_time;
class ambiguous_local_time;

struct sys_info;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const sys_info&amp; si);

struct local_info;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const local_info&amp; li);

enum class choose {earliest, latest};
class time_zone;

bool operator==(const time_zone&amp; x, const time_zone&amp; y);
bool operator!=(const time_zone&amp; x, const time_zone&amp; y);

bool operator&lt;(const time_zone&amp; x, const time_zone&amp; y);
bool operator&gt;(const time_zone&amp; x, const time_zone&amp; y);
bool operator&lt;=(const time_zone&amp; x, const time_zone&amp; y);
bool operator&gt;=(const time_zone&amp; x, const time_zone&amp; y);

ostream&amp; operator&lt;&lt;(ostream&amp; os, const time_zone&amp; z);

template &lt;class Duration&gt; class zoned_time;

using zoned_seconds = zoned_time&lt;seconds&gt;;

template &lt;class Duration1, class Duration2&gt;
    bool
    operator==(const zoned_time&lt;Duration1&gt;&amp; x, const zoned_time&lt;Duration2&gt;&amp; y);

template &lt;class Duration1, class Duration2&gt;
    bool
    operator!=(const zoned_time&lt;Duration1&gt;&amp; x, const zoned_time&lt;Duration2&gt;&amp; y);

template &lt;class Duration&gt;
    basic_ostream&lt;class charT, class traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;class charT, class traits&gt;&amp; os, const zoned_time&lt;Duration&gt;& t);

// make_zoned

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(sys_time&lt;Duration&gt; tp);

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(const time_zone* zone, local_time&lt;Duration&gt; tp);

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(const string&amp; name, local_time&lt;Duration&gt; tp);

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(const time_zone* zone, local_time&lt;Duration&gt; tp, choose c);

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(const string&amp; name, local_time&lt;Duration&gt; tp, choose c);

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(const time_zone* zone, const zoned_time&lt;Duration&gt;&amp; zt);

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(const string&amp; name, const zoned_time&lt;Duration&gt;&amp; zt);

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(const time_zone* zone, const zoned_time&lt;Duration&gt;&amp; zt, choose c);

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(const string&amp; name, const zoned_time&lt;Duration&gt;&amp; zt, choose c);

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(const time_zone* zone, const sys_time&lt;Duration&gt;&amp; st);

template &lt;class Duration&gt;
    zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
    make_zoned(const string&amp; name, const sys_time&lt;Duration&gt;&amp; st);

// format

template &lt;class charT, class traits, class Duration&gt;
    basic_string&lt;class charT, class traits&gt;
    format(const locale&amp; loc, basic_string&lt;class charT, class traits&gt; format,
           const local_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class traits, class Duration&gt;
    basic_string&lt;class charT, class traits&gt;
    format(basic_string&lt;class charT, class traits&gt; format, const local_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class traits, class Duration&gt;
    basic_string&lt;class charT, class traits&gt;
    format(const locale&amp; loc, basic_string&lt;class charT, class traits&gt; format,
           const zoned_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class traits, class Duration&gt;
    basic_string&lt;class charT, class traits&gt;
    format(basic_string&lt;class charT, class traits&gt; format, const zoned_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class traits, class Duration&gt;
    basic_string&lt;class charT, class traits&gt;
    format(const locale&amp; loc, basic_string&lt;class charT, class traits&gt; format,
           const sys_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class traits, class Duration&gt;
    basic_string&lt;class charT, class traits&gt;
    format(basic_string&lt;class charT, class traits&gt; format, const sys_time&lt;Duration&gt;&amp; tp);

// const charT* formats

template &lt;class charT, class Duration&gt;
    basic_string&lt;class charT&gt;
    format(const locale&amp; loc, const charT* format, const local_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class Duration&gt;
    basic_string&lt;class charT&gt;
    format(const charT* format, const local_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class Duration&gt;
    basic_string&lt;class charT&gt;
    format(const locale&amp; loc, const charT* format, const zoned_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class Duration&gt;
    basic_string&lt;class charT&gt;
    format(const charT* format, const zoned_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class Duration&gt;
    basic_string&lt;class charT&gt;
    format(const locale&amp; loc, const charT* format, const sys_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class Duration&gt;
    basic_string&lt;class charT&gt;
    format(const charT* format, const sys_time&lt;Duration&gt;&amp; tp);

// parse

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const basic_string&lt;charT, traits&gt;&amp; format, sys_time&lt;Duration&gt;&amp; tp);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const basic_string&lt;charT, traits&gt;&amp; format, sys_time&lt;Duration&gt;&amp; tp,
          basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const basic_string&lt;charT, traits&gt;&amp; format, sys_time&lt;Duration&gt;&amp; tp,
          minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const basic_string&lt;charT, traits&gt;&amp; format, sys_time&lt;Duration&gt;&amp; tp,
          basic_string&lt;charT, traits&gt;&amp; abbrev, minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const basic_string&lt;charT, traits&gt;&amp; format, sys_time&lt;Duration&gt;&amp; tp,
          minutes&amp; offset, basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const basic_string&lt;charT, traits&gt;&amp; format, local_time&lt;Duration&gt;&amp; tp);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const basic_string&lt;charT, traits&gt;&amp; format, local_time&lt;Duration&gt;&amp; tp,
          basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const basic_string&lt;charT, traits&gt;&amp; format, local_time&lt;Duration&gt;&amp; tp,
          minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const basic_string&lt;charT, traits&gt;&amp; format, local_time&lt;Duration&gt;&amp; tp,
          basic_string&lt;charT, traits&gt;&amp; abbrev, minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const basic_string&lt;charT, traits&gt;&amp; format, local_time&lt;Duration&gt;&amp; tp,
          minutes&amp; offset, basic_string&lt;charT, traits&gt;&amp; abbrev);

// const charT* formats

template &lt;class Duration, class charT&gt;
    <i>unspecified</i>
    parse(const charT* format, sys_time&lt;Duration&gt;&amp; tp);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const charT* format, sys_time&lt;Duration&gt;&amp; tp,
          basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT&gt;
    <i>unspecified</i>
    parse(const charT* format, sys_time&lt;Duration&gt;&amp; tp,
          minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const charT* format, sys_time&lt;Duration&gt;&amp; tp,
          basic_string&lt;charT, traits&gt;&amp; abbrev, minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const charT* format, sys_time&lt;Duration&gt;&amp; tp,
          minutes&amp; offset, basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT&gt;
    <i>unspecified</i>
    parse(const charT* format, local_time&lt;Duration&gt;&amp; tp);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const charT* format, local_time&lt;Duration&gt;&amp; tp,
          basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT&gt;
    <i>unspecified</i>
    parse(const charT* format, local_time&lt;Duration&gt;&amp; tp,
          minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const charT* format, local_time&lt;Duration&gt;&amp; tp,
          basic_string&lt;charT, traits&gt;&amp; abbrev, minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
    <i>unspecified</i>
    parse(const charT* format, local_time&lt;Duration&gt;&amp; tp,
          minutes&amp; offset, basic_string&lt;charT, traits&gt;&amp; abbrev);

// leap second support

class leap;

bool operator==(const leap&amp; x, const leap&amp; y);
bool operator!=(const leap&amp; x, const leap&amp; y);
bool operator&lt; (const leap&amp; x, const leap&amp; y);
bool operator&gt; (const leap&amp; x, const leap&amp; y);
bool operator&lt;=(const leap&amp; x, const leap&amp; y);
bool operator&gt;=(const leap&amp; x, const leap&amp; y);

template &lt;class Duration&gt; bool operator==(const const leap&amp;         x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator==(const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
template &lt;class Duration&gt; bool operator!=(const leap&amp;               x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator!=(const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
template &lt;class Duration&gt; bool operator&lt; (const leap&amp;               x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator&lt; (const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
template &lt;class Duration&gt; bool operator&gt; (const leap&amp;               x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator&gt; (const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
template &lt;class Duration&gt; bool operator&lt;=(const leap&amp;               x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator&lt;=(const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
template &lt;class Duration&gt; bool operator&gt;=(const leap&amp;               x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator&gt;=(const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);

class link;

bool operator==(const link&amp; x, const link&amp; y);
bool operator!=(const link&amp; x, const link&amp; y);
bool operator&lt; (const link&amp; x, const link&amp; y);
bool operator&gt; (const link&amp; x, const link&amp; y);
bool operator&lt;=(const link&amp; x, const link&amp; y);
bool operator&gt;=(const link&amp; x, const link&amp; y);

} // namespace chrono

inline namespace literals {
inline namespace chrono_literals {
// ...
constexpr chrono::last_spec last{};

constexpr chrono::weekday sun{0};
constexpr chrono::weekday mon{1};
constexpr chrono::weekday tue{2};
constexpr chrono::weekday wed{3};
constexpr chrono::weekday thu{4};
constexpr chrono::weekday fri{5};
constexpr chrono::weekday sat{6};

constexpr chrono::month jan{1};
constexpr chrono::month feb{2};
constexpr chrono::month mar{3};
constexpr chrono::month apr{4};
constexpr chrono::month may{5};
constexpr chrono::month jun{6};
constexpr chrono::month jul{7};
constexpr chrono::month aug{8};
constexpr chrono::month sep{9};
constexpr chrono::month oct{10};
constexpr chrono::month nov{11};
constexpr chrono::month dec{12};

constexpr chrono::day  operator "" d(unsigned long long d) noexcept;
constexpr chrono::year operator "" y(unsigned long long y) noexcept;
}
}
</pre></blockquote>

<blockquote class = note><p>
Add new section [time.duration.io] after 20.17.5.9 duration algorithms [time.duration.alg]:
</p></blockquote>

<h3>20.17.5.10 duration stream insertion [time.duration.io]</h3>

<pre>
template &lt;class charT, class traits, class Rep, class Period&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
           const duration&lt;Rep, Period&gt;&amp; d);
</pre>

<blockquote>
<p>
<i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
os &lt;&lt; d.count() &lt;&lt; get_units&lt;charT&gt;(typename Period::type{});
</pre>
<p>
Where <code>get_units&lt;charT&gt;(typename Period::type{})</code> is an
exposition-only function which returns a null-terminated string of
<code>charT</code> which depends on <code>Period::type</code> as follows
(let <code>period</code> be the type <code>Period::type</code>):
</p>

<ul>
<li>If <code>period</code> is type <code>atto</code>, <code>as</code>, else</li>
<li>if <code>period</code> is type <code>femto</code>, <code>fs</code>, else</li>
<li>if <code>period</code> is type <code>pico</code>, <code>ps</code>, else</li>
<li>if <code>period</code> is type <code>nano</code>, <code>ns</code>, else</li>
<li>if <code>period</code> is type <code>micro</code>, <code>&micro;s</code> (U+00B5), else</li>
<li>if <code>period</code> is type <code>milli</code>, <code>ms</code>, else</li>
<li>if <code>period</code> is type <code>centi</code>, <code>cs</code>, else</li>
<li>if <code>period</code> is type <code>deci</code>, <code>ds</code>, else</li>
<li>if <code>period</code> is type <code>ratio&lt;1&gt;</code>, <code>s</code>, else</li>
<li>if <code>period</code> is type <code>deca</code>, <code>das</code>, else</li>
<li>if <code>period</code> is type <code>hecto</code>, <code>hs</code>, else</li>
<li>if <code>period</code> is type <code>kilo</code>, <code>ks</code>, else</li>
<li>if <code>period</code> is type <code>mega</code>, <code>Ms</code>, else</li>
<li>if <code>period</code> is type <code>giga</code>, <code>Gs</code>, else</li>
<li>if <code>period</code> is type <code>tera</code>, <code>Ts</code>, else</li>
<li>if <code>period</code> is type <code>peta</code>, <code>Ps</code>, else</li>
<li>if <code>period</code> is type <code>exa</code>, <code>Es</code>, else</li>
<li>if <code>period</code> is type <code>ratio&lt;60&gt;</code>, <code>min</code>, else</li>
<li>if <code>period</code> is type <code>ratio&lt;3600&gt;</code>, <code>h</code>, else</li>
<li>if <code>period::den == 1</code>, <code>[num]s</code>, else</li>
<li><code>[num/den]s</code>.</li>
</ul>

<p>
In the list above the use of <code>num</code> and <code>den</code> refer to the
static data members of <code>period</code> which are converted to arrays of
<code>charT</code> using a decimal conversion with no leading zeroes.
</p>

</blockquote>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<blockquote class = note><p>
Modify 20.17.7.1 [time.clock.system]:
</p></blockquote>

<p>
1 Objects of class <code>system_clock</code> represent wall clock time from the
system-wide realtime clock.
<ins><code>sys_time&lt;Duration&gt;</code> measures time since (and before) 1970-01-01
00:00:00 UTC <i>excluding</i> leap seconds.  This measure is commonly referred to
as <i>Unix Time</i>.  This measure facilitates an efficient mapping between
<code>sys_time</code> and calendar types ([time.calendar])</ins>
</p>

<ins><p>
[<i>Example:</i>
</p>

<blockquote><pre>
sys_seconds{sys_days{1970y/jan/1}}.time_since_epoch() is 0s
sys_seconds{sys_days{2000y/jan/1}}.time_since_epoch() is 946'684'800s which is 10'957 * 86'400s
</pre></blockquote>

<p>
&mdash;<i>end example</i>]
</p></ins>

<blockquote class = note><p>
Append new paragraphs after 20.17.7.1 [time.clock.system]/p4:
</p></blockquote>

<pre>
template &lt;class Duration&gt;
sys_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_sys_time(utc_time&lt;Duration&gt; u);
</pre>
<blockquote>
<p>
<i>Returns:</i> A <code>sys_time t</code>, such that <code>to_utc_time(t) == u</code>
if such a mapping exists. Otherwise <code>u</code> represents a
time_point during a leap second insertion and the last representable value of
<code>sys_time prior</code> to the insertion of the leap second is returned.
</p>
<p>
[<i>Example:</i>
</p>
<blockquote><pre>
auto t = sys_days{jul/1/2015} - 500ms;
auto u = utc_clock::sys_to_utc(t);
t = to_sys_time(u);
assert(u.time_since_epoch() - t.time_since_epoch() == 25s);
cout &lt;&lt; t &lt;&lt; " SYS == " &lt;&lt; u &lt;&lt; " UTC\n";
u += 250ms;
t = to_sys_time(u);
assert(u.time_since_epoch() - t.time_since_epoch() == 25s);
cout &lt;&lt; t &lt;&lt; " SYS == " &lt;&lt; u &lt;&lt; " UTC\n";
u += 250ms;
t = to_sys_time(u);
assert(u.time_since_epoch() - t.time_since_epoch() == 25001ms);
cout &lt;&lt; t &lt;&lt; " SYS == " &lt;&lt; u &lt;&lt; " UTC\n";
u += 250ms;
t = to_sys_time(u);
assert(u.time_since_epoch() - t.time_since_epoch() == 25251ms);
cout &lt;&lt; t &lt;&lt; " SYS == " &lt;&lt; u &lt;&lt; " UTC\n";
u += 250ms;
t = to_sys_time(u);
assert(u.time_since_epoch() - t.time_since_epoch() == 25501ms);
cout &lt;&lt; t &lt;&lt; " SYS == " &lt;&lt; u &lt;&lt; " UTC\n";
u += 250ms;
t = to_sys_time(u);
assert(u.time_since_epoch() - t.time_since_epoch() == 25751ms);
cout &lt;&lt; t &lt;&lt; " SYS == " &lt;&lt; u &lt;&lt; " UTC\n";
u += 250ms;
t = to_sys_time(u);
assert(u.time_since_epoch() - t.time_since_epoch() == 26s);
cout &lt;&lt; t &lt;&lt; " SYS == " &lt;&lt; u &lt;&lt; " UTC\n";
u += 250ms;
t = to_sys_time(u);
assert(u.time_since_epoch() - t.time_since_epoch() == 26s);
cout &lt;&lt; t &lt;&lt; " SYS == " &lt;&lt; u &lt;&lt; " UTC\n";
</pre></blockquote>
<p>
Output:
</p>
<blockquote><pre>
2015-06-30 23:59:59.500 SYS == 2015-06-30 23:59:59.500 UTC
2015-06-30 23:59:59.750 SYS == 2015-06-30 23:59:59.750 UTC
2015-06-30 23:59:59.999 SYS == 2015-06-30 23:59:60.000 UTC
2015-06-30 23:59:59.999 SYS == 2015-06-30 23:59:60.250 UTC
2015-06-30 23:59:59.999 SYS == 2015-06-30 23:59:60.500 UTC
2015-06-30 23:59:59.999 SYS == 2015-06-30 23:59:60.750 UTC
2015-07-01 00:00:00.000 SYS == 2015-07-01 00:00:00.000 UTC
2015-07-01 00:00:00.250 SYS == 2015-07-01 00:00:00.250 UTC
</pre></blockquote>
<p>
<i>&mdash; end example</i>]
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
sys_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_sys_time(tai_time&lt;Duration&gt; u);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to: <code>return to_sys_time(to_utc_time(u));</code>
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
sys_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_sys_time(gps_time&lt;Duration&gt; u);
</pre>
<blockquote>
<p>
<p>
<i>Effects:</i> Equivalent to: <code>return to_sys_time(to_utc_time(u));</code>
</p>
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
ostream&amp;
operator&lt;&lt;(ostream&amp; os, const sys_time&lt;Duration&gt;&amp; tp);
</pre>

<blockquote>
<p>
<i>Remarks:</i>  This operator shall not participate in overload resolution if
<code>treat_as_floating_point&lt;typename Duration::rep&gt;::value</code> is
true, or if <code>Duration{1} &gt;= days{1}</code>.
</p>
<p>
<i>Effects:</i>
</p>
<blockquote><pre>
auto const dp = floor&lt;days&gt;(tp);
os &lt;&lt; year_month_day{dp} &lt;&lt; ' ' &lt;&lt; make_time(tp-dp);
</pre></blockquote>
<p>
<i>Returns:</i> <code>os</code>.
</p>

<p>
[<i>Example:</i>
</p>
<blockquote><pre>
cout &lt;&lt; sys_seconds{0s} &lt;&lt; '\n';             // 1970-01-01 00:00:00
cout &lt;&lt; sys_seconds{946'684'800s} &lt;&lt; '\n';   // 2000-01-01 00:00:00
</pre></blockquote>
<p>
&mdash; <i>end example:</i>]
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const sys_days&amp; dp);
</pre>

<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote><pre>
os &lt;&lt; year_month_day{dp};
</pre></blockquote>

<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<blockquote class = note><p>
Add new section [time.clock.utc] after 20.17.7.1 Class system_clock [time.clock.system]:
</p></blockquote>

<h3>20.17.7.2 Class utc_clock [time.clock.utc]</h3>

<pre>
class utc_clock
{
public:
    using duration                  = system_clock::duration;
    using rep                       = duration::rep;
    using period                    = duration::period;
    using time_point                = chrono::time_point&lt;utc_clock&gt;;
    static constexpr bool is_steady = false;

    static time_point now() noexcept;
};
</pre>

<p>
In contrast to <code>sys_time</code> which does not take leap seconds into
account, <code>utc_clock</code> and its associated <code>time_point</code>,
<code>utc_time</code>, counts time, <i>including</i> leap seconds, since
1970-01-01 00:00:00 UTC.
</p>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
to_utc_time(sys_seconds{sys_days{1970y/jan/1}}).time_since_epoch() is 0s
to_utc_time(sys_seconds{sys_days{2000y/jan/1}}).time_since_epoch() is 946'684'822s which is 10'957 * 86'400s + 22s
</pre></blockquote>

<p>
&mdash;<i>end example</i>]
</p>

<pre>
static utc_clock::time_point utc_clock::now() noexcept;
</pre>
<blockquote>
<p>
<i>Returns:</i> The best measure available.  This may be approximated with
<code>to_utc_time(system_clock::now())</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
utc_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_utc_time(sys_time&lt;Duration&gt; t);
</pre>
<blockquote>
<p>
<i>Returns:</i> A <code>utc_time</code> <code>u</code>, such that
<code>u.time_since_epoch() - t.time_since_epoch()</code> is equal to the number
of leap seconds that were inserted between <code>t</code> and 1970-01-01.  If
<code>t</code> is exactly the date of leap second insertion, then the conversion
counts that leap second as inserted.
</p>
<p>
[<i>Example:</i>
</p>
<blockquote><pre>
auto t = sys_days{jul/1/2015} - 2ns;
auto u = to_utc_time(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 25s);
t += 1ns;
u = to_utc_time(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 25s);
t += 1ns;
u = to_utc_time(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 26s);
t += 1ns;
u = to_utc_time(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 26s);
</pre></blockquote>
<p>
<i>&mdash; end example</i>]
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
utc_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_utc_time(tai_time&lt;Duration&gt; t);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>utc_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;{t.time_since_epoch()} - 378691210s</code>
</p>
<p>
<i>Note:</i> <code>378691210s == sys_days{1970y/jan/1} - sys_days{1958y/jan/1} + 10s</code>
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
utc_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_utc_time(gps_time&lt;Duration&gt; t);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>utc_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;{t.time_since_epoch()} + 315964809s</code>
</p>
<p>
<i>Note:</i> <code>315964809s == sys_days{1980y/jan/sun[1]} - sys_days{1970y/jan/1} + 9s</code>
</p>
</blockquote>

<pre>
template &lt;class charT, class traits, class Duration&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const utc_time&lt;Duration&gt;&amp; t);
</pre>
<blockquote>
<p>
<i>Effects:</i> Streams to <code>os</code> the same value as it would for
<code>to_sys_time(t)</code>, except that during a leap second
insertion, the seconds field is streamed as <code>60</code> (plus whatever fractional
seconds is applicable).
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
<p>
[<i>Example:</i>
</p>
<blockquote><pre>
auto t = sys_days{jul/1/2015} - 500ms;
auto u = utc_clock::sys_to_utc(t);
for (auto i = 0; i &lt; 8; ++i, u += 250ms)
    cout &lt;&lt; u &lt;&lt; " UTC\n";
</pre></blockquote>
<p>
Output:
</p>
<blockquote><pre>
2015-06-30 23:59:59.500 UTC
2015-06-30 23:59:59.750 UTC
2015-06-30 23:59:60.000 UTC
2015-06-30 23:59:60.250 UTC
2015-06-30 23:59:60.500 UTC
2015-06-30 23:59:60.750 UTC
2015-07-01 00:00:00.000 UTC
2015-07-01 00:00:00.250 UTC
</pre></blockquote>
<p>
<i>&mdash; end example</i>]
</p>
</blockquote>

<blockquote class = note><p>
Add new section [time.clock.tai] after 20.17.7.2 Class utc_clock [time.clock.utc]:
</p></blockquote>

<h3>20.17.7.3 Class tai_clock [time.clock.tai]</h3>

<pre>
class tai_clock
{
public:
    using duration                  = system_clock::duration;
    using rep                       = duration::rep;
    using period                    = duration::period;
    using time_point                = chrono::time_point&lt;tai_clock&gt;;
    static constexpr bool is_steady = false;

    static time_point now() noexcept;
};
</pre>

<p>
The clock <code>tai_clock</code> measures seconds since 1958-01-01 00:00:00 and is
offset 10s ahead of UTC at this date.  That is, 1958-01-01 00:00:00 TAI is equivalent
to 1957-12-31 23:59:50 UTC. Leap seconds are not inserted into TAI.  Therefore every
time a leap second is inserted into UTC, UTC falls another second behind TAI.  For
example by 2000-01-01 there had been 22 leap seconds inserted so 2000-01-01 00:00:00 UTC
is equivalent to 2000-01-01 00:00:32 TAI (22s plus the initial 10s offset).
</p>

<pre>
static tai_clock::time_point tai_clock::now() noexcept;
</pre>
<blockquote>
<p>
<i>Returns:</i> The best measure available.  This may be approximated with
<code>to_tai_time(system_clock::now())</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
tai_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_tai_time(sys_time&lt;Duration&gt; t);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to: <code>return to_tai_time(to_utc_time(t));</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
tai_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_tai_time(utc_time&lt;Duration&gt; t);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>tai_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;{t.time_since_epoch()} + 378691210s</code>
</p>
<p>
<i>Note:</i> <code>378691210s == sys_days{1970y/jan/1} - sys_days{1958y/jan/1} + 10s</code>
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
tai_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_tai_time(gps_time&lt;Duration&gt; t);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>tai_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;{t.time_since_epoch()} + 694656019s</code>
</p>
<p>
<i>Note:</i> <code>694656019s == sys_days{1980y/jan/sun[1]} - sys_days{1958y/jan/1} + 19s</code>
</p>
</blockquote>

<pre>
template &lt;class charT, class traits, class Duration&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const tai_time&lt;Duration&gt;&amp; t);
</pre>
<blockquote>
<p>
<i>Effects:</i> Creates a <code>sys_time</code> from <code>t</code> as if by:
</p>
<blockquote><pre>
auto tp = sys_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;{t.time_since_epoch()} -
              (sys_days{1970y/jan/1} - sys_days{1958y/jan/1});
</pre></blockquote>
<p>
And then streams that <code>sys_time</code>: <code>os &lt;&lt; tp</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<blockquote class = note><p>
Add new section [time.clock.gps] after 20.17.7.3 Class tai_clock [time.clock.tai]:
</p></blockquote>

<h3>20.17.7.4 Class gps_clock [time.clock.gps]</h3>

<pre>
class gps_clock
{
public:
    using duration                  = system_clock::duration;
    using rep                       = duration::rep;
    using period                    = duration::period;
    using time_point                = chrono::time_point&lt;gps_clock&gt;;
    static constexpr bool is_steady = false;

    static time_point now() noexcept;
};
</pre>

<p>
The clock <code>gps_clock</code> measures seconds since The first Sunday of January,
1980 00:00:00 UTC.  Leap seconds are not inserted into GPS.  Therefore every
time a leap second is inserted into UTC, UTC falls another second behind GPS.  Aside
from the offset from 1958y/jan/1 to 1980y/jan/sun[1] GPS is behind TAI by 19s due to
the 10s offset between 1958 and 1970 and the additional 9 leap seconds inserted between
1970 and 1980.
</p>

<pre>
static gps_clock::time_point gps_clock::now() noexcept;
</pre>
<blockquote>
<p>
<i>Returns:</i> The best measure available.  This may be approximated with
<code>to_gps_time(system_clock::now())</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
gps_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_gps_time(sys_time&lt;Duration&gt; t);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to: <code>return to_gps_time(to_utc_time(t));</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
gps_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_gps_time(utc_time&lt;Duration&gt; t);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>gps_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;{t.time_since_epoch()} - 315964809s</code>
</p>
<p>
<i>Note:</i> <code>315964809s == sys_days{1980y/jan/sun[1]} - sys_days{1970y/jan/1} + 9s</code>
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
gps_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
to_gps_time(tai_time&lt;Duration&gt; t);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>gps_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;{t.time_since_epoch()} - 694656019s</code>
</p>
<p>
<i>Note:</i> <code>694656019s == sys_days{1980y/jan/sun[1]} - sys_days{1958y/jan/1} + 19s</code>
</p>
</blockquote>

<pre>
template &lt;class charT, class traits, class Duration&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const gps_time&lt;Duration&gt;&amp; t);
</pre>
<blockquote>
<p>
<i>Effects:</i> Creates a <code>sys_time</code> from <code>t</code> as if by:
</p>
<blockquote><pre>
auto tp = sys_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;{t.time_since_epoch()} +
              (sys_days{1980y/jan/sun[1]} - sys_days{1970y/jan/1});
</pre></blockquote>
<p>
And then streams that <code>sys_time</code>: <code>os &lt;&lt; tp</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<blockquote class = note><p>
Add new section [time.clock.local_time] after 20.17.7.3 Class high_resolution_clock [time.clock.hres]:
</p></blockquote>

<h3>20.17.7.7 local_time [time.clock.local_time]</h3>

<p>
The family of time points denoted by <code>local_time&lt;Duration&gt;</code> are
based on the <i>pseudo clock</i> <code>local_t</code>.  <code>local_t</code> has
no member <code>now()</code> and thus does not meet the clock requirements. 
Nevertheless <code>local_time&lt;Duration&gt;</code> serves the vital role of
representing time local with respect to a not-yet-specified time zone.  Aside
from being able to get the current time, the complete <code>time_point</code>
algebra is available for <code>local_time&lt;Duration&gt;</code> (just as for
<code>sys_time&lt;Duration&gt;</code>).
</p>

<p>
The following stream insertion operators exist for <code>local_time&lt;Duration&gt;</code>:
</p>

<pre>
template &lt;class Duration&gt; ostream&amp; operator&lt;&lt;(ostream&amp; os, const local_time&lt;Duration&gt;&amp; lt);
</pre>

<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote><pre>
os &lt;&lt; sys_time&lt;Duration&gt;{lt.time_since_epoch()};
</pre></blockquote>

<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<blockquote class = note><p>
Add new section [time.calendar] after 20.17.7 Clocks [time.clocks]:
</p></blockquote>

<h3>20.17.8 The civil calendar [time.calendar]</h3>

<p>
The types in this subclause describe the civil (Gregorian) calendar and its relationship
to <code>sys_days</code> and <code>local_days</code>.
</p>

<h4>20.17.8.1 Class <code>last_spec</code> [time.calendar.last]</h4>

<p>
The struct <code>last_spec</code> is used in conjunction with other calendar types to 
indicate the last in a sequence.  For example, depending on context, it can represent 
the last day of a month, or the last day of the week of a month.
</p>

<p>
There is an <code>constexpr</code> object of this type named <code>last</code> in the
<code>chrono_literals</code> namespace.
</p>

<pre>
struct last_spec
{
    explicit last_spec() = default;
};
</pre>

<h4>20.17.8.2 Class <code>day</code> [time.calendar.day]</h4>

<p>
<code>day</code> represents a day of a month.  It normally holds values in
the range 1 to 31.  However it may hold non-negative values outside this range.  It can be constructed
with any <code>unsigned</code> value, which will be subsequently truncated to fit into
<code>day</code>'s unspecified internal storage.  <code>day</code> is equality and less-than
comparable, and participates in basic arithmetic with <code>days</code> representing the
quantity between any two <code>day</code>'s.  One can form a <code>day</code> literal with
<code>d</code>.  And one can stream out a <code>day</code> .
<code>day</code> has explicit conversions to and from <code>unsigned</code>.
</p>

<pre>
class day
{
    unsigned char d_;  // exposition only
public:
    day() = default;
    explicit constexpr day(unsigned d) noexcept;

    constexpr day&amp; operator++()    noexcept;
    constexpr day  operator++(int) noexcept;
    constexpr day&amp; operator--()    noexcept;
    constexpr day  operator--(int) noexcept;

    constexpr day&amp; operator+=(const days&amp; d) noexcept;
    constexpr day&amp; operator-=(const days&amp; d) noexcept;

    constexpr explicit operator unsigned() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator!=(const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&lt; (const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&gt; (const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&lt;=(const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&gt;=(const day&amp; x, const day&amp; y) noexcept;

constexpr day  operator+(const day&amp;  x, const days&amp; y) noexcept;
constexpr day  operator+(const days&amp; x, const day&amp;  y) noexcept;
constexpr day  operator-(const day&amp;  x, const days&amp; y) noexcept;
constexpr days operator-(const day&amp;  x, const day&amp;  y) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const day&amp; d);
</pre>

<p>
<code>day</code> is a trivially copyable class type.</br>
<code>day</code> is a standard-layout class type.</br>
<code>day</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr day::day(unsigned d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>day</code> by constructing
<code>d_</code> with <code>d</code>.
</p>
</blockquote>

<pre>
constexpr day&amp; day::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++d_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr day day::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
constexpr day&amp; day::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--d_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr day day::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
constexpr day&amp; day::operator+=(const days&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + d</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr day&amp; day::operator-=(const days&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - d</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit day::operator unsigned() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>d_</code>.
</p>
</blockquote>

<pre>
constexpr bool day::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>1 <= d_ && d_ <= 31</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>unsigned{x} == unsigned{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>unsigned{x} &lt; unsigned{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr day  operator+(const day&amp;  x, const days&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>day{unsigned{x} + y.count()}</code>.
</p>
</blockquote>

<pre>
constexpr day  operator+(const days&amp; x, const day&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr day  operator-(const day&amp;  x, const days&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr days operator-(const day&amp;  x, const day&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>days{static_cast&lt;days::rep&gt;(unsigned{x} - unsigned{y})}</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const day&amp; d);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts a decimal integral text representation of <code>d</code> into
<code>os</code>.  Single digit values are prefixed with <code>'0'</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<pre>
constexpr day operator "" d(unsigned long long d) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>day{static_cast&lt;unsigned&gt;(d)}</code>.
</p>
</blockquote>

<h4>20.17.8.3 Class <code>month</code> [time.calendar.month]</h4>

<p>
<code>month</code> represents a month of a year.  It normally holds values in
the range 1 to 12.  However it may hold non-negative values outside this range. 
It can be constructed with any <code>unsigned</code> value, which will be
subsequently truncated to fit into <code>month</code>'s unspecified internal
storage.  <code>month</code> is equality and less-than comparable, and
participates in basic arithmetic with <code>months</code> representing the
quantity between any two <code>month</code>'s.   One can stream out a
<code>month</code>. <code>month</code> has explicit conversions to and from
<code>unsigned</code>.  There are 12 <code>month</code> constants, one for each
month of the year in the <code>chrono_literals</code> namespace.
</p>

<pre>
class month
{
    unsigned char m_;  // exposition only
public:
    month() = default;
    explicit constexpr month(unsigned m) noexcept;

    constexpr month&amp; operator++()    noexcept;
    constexpr month  operator++(int) noexcept;
    constexpr month&amp; operator--()    noexcept;
    constexpr month  operator--(int) noexcept;

    constexpr month&amp; operator+=(const months&amp; m) noexcept;
    constexpr month&amp; operator-=(const months&amp; m) noexcept;

    constexpr explicit operator unsigned() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator!=(const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&lt; (const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&gt; (const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&lt;=(const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&gt;=(const month&amp; x, const month&amp; y) noexcept;

constexpr month  operator+(const month&amp;  x, const months&amp; y) noexcept;
constexpr month  operator+(const months&amp; x,  const month&amp; y) noexcept;
constexpr month  operator-(const month&amp;  x, const months&amp; y) noexcept;
constexpr months operator-(const month&amp;  x,  const month&amp; y) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const month&amp; m);
</pre>

<p>
<code>month</code> is a trivially copyable class type.</br>
<code>month</code> is a standard-layout class type.</br>
<code>month</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr month::month(unsigned m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>month</code> by constructing
<code>m_</code> with <code>m</code>.
</p>
</blockquote>

<pre>
constexpr month&amp; month::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>m_ != 12</code>, <code>++m_</code>.  Otherwise sets
<code>m_</code> to 1.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr month month::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
constexpr month&amp; month::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>m_ != 1</code>, <code>--m_</code>.  Otherwise sets
<code>m_</code> to 12.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr month month::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
constexpr month&amp; month::operator+=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + m</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr month&amp; month::operator-=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - m</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit month::operator unsigned() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr bool month::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>1 <= m_ && m_ <= 12</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>unsigned{x} == unsigned{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>unsigned{x} &lt; unsigned{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr month  operator+(const month&amp;  x, const months&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> A <code>month</code> for which <code>ok() == true</code> and is found as
if by incrementing (or decrementing if <code>y &lt; months{0}</code>) <code>x</code>,
<code>y</code> times.  If <code>month.ok() == false</code> prior to this operation,
behaves as if <code>*this</code> is first brought into the range [1, 12] by modular
arithmetic. [<i>Note:</i> For example <code>month{0}</code> becomes <code>month{12}</code>,
and <code>month{13}</code> becomes <code>month{1}</code>. &mdash; <i>end note</i>]
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>y</code>.  That is, repeated
increments or decrements is not a valid implementation.
</p>
<p>
<i>Example:</i> <code>feb + months{11} == jan</code>.
</p>
</blockquote>

<pre>
constexpr month  operator+(const months&amp; x, const month&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr month  operator-(const month&amp;  x, const months&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr months operator-(const month&amp;  x, const month&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>x.ok() == true</code> and <code>y.ok() == true</code>.
</p>
<p>
<i>Returns:</i> A value of <code>months</code> in the range of <code>months{0}</code> to
<code>months{11}</code> inclusive.
</p>
<p>
<i>Remarks:</i> The returned value <code>m</code> shall satisfy the equality:
<code>y + m == x</code>.
</p>
<p>
<i>Example:</i> <code>jan - feb == months{11} </code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const month&amp; m);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>ok() == true</code> outputs the same string that would be
output for the month field by <code>asctime</code>.  Otherwise outputs
<code>unsigned{m} &lt;&lt; " is not a valid month"</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.4 Class <code>year</code> [time.calendar.year]</h4>

<p>
<code>year</code> represents a year in the civil calendar.  It shall represent values
in the range <code>[min(), max()]</code>.  It can be constructed with any
<code>int</code> value, which will be subsequently truncated to fit into
<code>year</code>'s internal unspecified storage.  <code>year</code> is equality and less-than
comparable, and participates in basic arithmetic with <code>years</code> representing the
quantity between any two <code>year</code>'s.  One can form a <code>year</code> literal
with <code>y</code>.  And one can stream out a <code>year</code>.
<code>year</code> has explicit conversions to and from <code>int</code>.
</p>

<pre>
class year
{
    short y_;  // exposition only
public:
    year() = default;
    explicit constexpr year(int y) noexcept;

    constexpr year&amp; operator++()    noexcept;
    constexpr year  operator++(int) noexcept;
    constexpr year&amp; operator--()    noexcept;
    constexpr year  operator--(int) noexcept;

    constexpr year&amp; operator+=(const years&amp; y) noexcept;
    constexpr year&amp; operator-=(const years&amp; y) noexcept;

    constexpr bool is_leap() const noexcept;

    constexpr explicit operator int() const noexcept;
    constexpr bool ok() const noexcept;

    static constexpr year min() noexcept;
    static constexpr year max() noexcept;
};

constexpr bool operator==(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator!=(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&lt; (const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&gt; (const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&lt;=(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&gt;=(const year&amp; x, const year&amp; y) noexcept;

constexpr year  operator+(const year&amp;  x, const years&amp; y) noexcept;
constexpr year  operator+(const years&amp; x, const year&amp;  y) noexcept;
constexpr year  operator-(const year&amp;  x, const years&amp; y) noexcept;
constexpr years operator-(const year&amp;  x, const year&amp;  y) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const year&amp; y);
</pre>

<p>
<code>year</code> is a trivially copyable class type.</br>
<code>year</code> is a standard-layout class type.</br>
<code>year</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr year::year(int y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year</code> by constructing
<code>y_</code> with <code>y</code>.
</p>
</blockquote>

<pre>
constexpr year&amp; year::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++y_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year year::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
constexpr year&amp; year::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--y_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year year::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
constexpr year&amp; year::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year&amp; year::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr bool year::is_leap() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>true</code> if <code>*this</code> represents a leap year, else
returns <code>false</code>.
</p>
</blockquote>

<pre>
constexpr explicit year::operator int() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr bool year::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>true</code>.
</p>
</blockquote>

<pre>
static constexpr year year::min() noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>year{numeric_limits&lt;decltype(y_)&gt;::min()}</code>.
</p>
</blockquote>

<pre>
static constexpr year year::max() noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>year{numeric_limits&lt;decltype(y_)&gt;::max()}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>int{x} == int{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>int{x} &lt; int{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr year  operator+(const year&amp;  x, const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>year{int{x} + y.count()}</code>.
</p>
</blockquote>

<pre>
constexpr year  operator+(const years&amp; x, const year&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr year  operator-(const year&amp;  x, const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr years operator-(const year&amp;  x, const year&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>years{int{x} - int{y}}</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const year&amp; y);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts a signed decimal integral text representation of <code>y</code>
into <code>os</code>. If the year is less than four decimal digits, pads the year with
<code>'0'</code> to four digits.  If the year is negative, prefixes with <code>'-'</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<pre>
constexpr year operator "" y(unsigned long long y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>year{static_cast&lt;int&gt;(y)}</code>.
</p>
</blockquote>

<h4>20.17.8.5 Class <code>weekday</code> [time.calendar.weekday]</h4>

<p>
<code>weekday</code> represents a day of the week in the civil calendar.  It
normally holds values in the range 0 to 6, corresponding to Sunday thru
Saturday. However it may hold non-negative values outside this range.  It can be
constructed with any <code>unsigned</code> value, which will be subsequently
truncated to fit into <code>weekday</code>'s unspecified internal storage. 
<code>weekday</code> is equality comparable. <code>weekday</code> is not
less-than comparable because there is no universal consensus on which day is the
first day of the week.  This design chooses the encoding of 0 to 6 to represent
Sunday thru Saturday only because this is consistent with existing C and C++
practice.  However  <code>weekday</code>'s comparison and arithmetic operations
treat the days of the week as a circular range, with no beginning and no end.  
One can stream out a <code>weekday</code>. <code>weekday</code> has explicit
conversions to and from <code>unsigned</code>.  There are 7 <code>weekday</code>
constants, one for each day of the week in the <code>chrono_literals</code>
namespace.
</p>

<p>
A <code>weekday</code> can be implicitly constructed from a <code>sys_days</code>. This
is the computation that discovers the day of the week of an arbitrary date.
</p>

<p>
A <code>weekday</code> can be indexed with either <code>unsigned</code> or
<code>last</code>. This produces new types which represent the first, second, third,
fourth, fifth or last weekdays of a month.
</p>

<pre>
class weekday
{
    unsigned char wd_;  // exposition only
public:
    weekday() = default;
    explicit constexpr weekday(unsigned wd) noexcept;
    constexpr weekday(const sys_days&amp; dp) noexcept;
    constexpr explicit weekday(const local_days&amp; dp) noexcept;

    constexpr weekday&amp; operator++()    noexcept;
    constexpr weekday  operator++(int) noexcept;
    constexpr weekday&amp; operator--()    noexcept;
    constexpr weekday  operator--(int) noexcept;

    constexpr weekday&amp; operator+=(const days&amp; d) noexcept;
    constexpr weekday&amp; operator-=(const days&amp; d) noexcept;

    constexpr explicit operator unsigned() const noexcept;
    constexpr bool ok() const noexcept;

    constexpr weekday_indexed operator[](unsigned index) const noexcept;
    constexpr weekday_last    operator[](last_spec) const noexcept;
};

constexpr bool operator==(const weekday&amp; x, const weekday&amp; y) noexcept;
constexpr bool operator!=(const weekday&amp; x, const weekday&amp; y) noexcept;

constexpr weekday operator+(const weekday&amp; x, const days&amp;    y) noexcept;
constexpr weekday operator+(const days&amp;    x, const weekday&amp; y) noexcept;
constexpr weekday operator-(const weekday&amp; x, const days&amp;    y) noexcept;
constexpr days    operator-(const weekday&amp; x, const weekday&amp; y) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const weekday&amp; wd);
</pre>

<p>
<code>weekday</code> is a trivially copyable class type.</br>
<code>weekday</code> is a standard-layout class type.</br>
<code>weekday</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr weekday::weekday(unsigned wd) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday</code> by constructing
<code>wd_</code> with <code>wd</code>.
</p>
</blockquote>

<pre>
constexpr weekday(const sys_days&amp; dp) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday</code> by computing what day
of the week corresponds to the <code>sys_days dp</code>, and representing that day of
the week in <code>wd_</code>.
</p>
<p>
<i>Example:</i> If <code>dp</code> represents 1970-01-01, the constructed
<code>weekday</code> shall represent Thursday by storing 4 in <code>wd_</code>.
</p>
</blockquote>

<pre>
constexpr explicit weekday(const local_days&amp; dp) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday</code> by computing what day
of the week corresponds to the <code>local_days dp</code>, and representing that day of
the week in <code>wd_</code>.
</p>
<p>
The value after construction shall be identical to that constructed from
<code>sys_days{dp.time_since_epoch()}</code>.
</p>
</blockquote>

<pre>
constexpr weekday&amp; weekday::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>wd_ != 6</code>, <code>++wd_</code>.  Otherwise sets
<code>wd_</code> to 0.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr weekday weekday::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
constexpr weekday&amp; weekday::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>wd_ != 0</code>, <code>--wd_</code>.  Otherwise sets
<code>wd_</code> to 6.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr weekday weekday::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
constexpr weekday&amp; weekday::operator+=(const days&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + d</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr weekday&amp; weekday::operator-=(const days&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - d</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit weekday::operator unsigned() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_</code>.
</p>
</blockquote>

<pre>
constexpr bool weekday::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_ <= 6</code>.
</p>
</blockquote>

<pre>
constexpr weekday_indexed weekday::operator[](unsigned index) const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>{*this, index}</code>.
</p>
</blockquote>

<pre>
constexpr weekday_last weekday::operator[](last_spec) const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>weekday_last{*this}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const weekday&amp; x, const weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>unsigned{x} == unsigned{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const weekday&amp; x, const weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr weekday  operator+(const weekday&amp;  x, const days&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> A <code>weekday</code> for which <code>ok() == true</code> and is found as
if by incrementing (or decrementing if <code>y &lt; days{0}</code>) <code>x</code>,
<code>y</code> times.  If <code>weekday.ok() == false</code> prior to this operation,
behaves as if <code>*this</code> is first brought into the range [0, 6] by modular
arithmetic. [<i>Note:</i> For example <code>weekday{7}</code> becomes
<code>weekday{0}</code>. &mdash; <i>end note</i>]
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>y</code>.  That is, repeated
increments or decrements is not a valid implementation.
</p>
<p>
<i>Example:</i> <code>mon + days{6} == sun</code>.
</p>
</blockquote>

<pre>
constexpr weekday  operator+(const days&amp; x, const weekday&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr weekday  operator-(const weekday&amp;  x, const days&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr days operator-(const weekday&amp;  x, const weekday&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>x.ok() == true</code> and <code>y.ok() == true</code>.
</p>
<p>
<i>Returns:</i> A value of <code>days</code> in the range of <code>days{0}</code> to
<code>days{6}</code> inclusive.
</p>
<p>
<i>Remarks:</i> The returned value <code>d</code> shall satisfy the equality:
<code>y + d == x</code>.
</p>
<p>
<i>Example:</i> <code>sun - mon == days{6}</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const weekday&amp; wd);
</pre>

<blockquote>
<p>
<i>Effects:</i>  If <code>ok() == true</code> outputs the same string that would be
output for the weekday field by <code>asctime</code>.  Otherwise outputs
<code>unsigned{wd} &lt;&lt; " is not a valid weekday"</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.6 Class <code>weekday_indexed</code> [time.calendar.weekday_indexed]</h4>

<p>
<code>weekday_indexed</code> represents a <code>weekday</code> and a small index in the
range 1 to 5. This class is used to represent the first, second, third, fourth or fifth
weekday of a month.  It is most easily constructed by indexing a <code>weekday</code>.
</p>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
constexpr auto wdi = sun[2];  // wdi is the second Sunday of an as yet unspecified month
static_assert(wdi.weekday() == sun);
static_assert(wdi.index() == 2);
</pre></blockquote>

<p>
&mdash; <i>end example:</i>]
</p>

<pre>
class weekday_indexed
{
    chrono::weekday  wd_;     // exposition only
    unsigned char    index_;  // exposition only

public:
    constexpr weekday_indexed(const chrono::weekday&amp; wd, unsigned index) noexcept;

    constexpr chrono::weekday weekday() const noexcept;
    constexpr unsigned        index()   const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const weekday_indexed&amp; x, const weekday_indexed&amp; y) noexcept;
constexpr bool operator!=(const weekday_indexed&amp; x, const weekday_indexed&amp; y) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const weekday_indexed&amp; wdi);
</pre>

<p>
<code>weekday_indexed</code> is a trivially copyable class type.</br>
<code>weekday_indexed</code> is a standard-layout class type.</br>
<code>weekday_indexed</code> is a literal class type.</br>
</p>

<pre>
constexpr weekday_indexed::weekday_indexed(const chrono::weekday&amp; wd, unsigned index) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday_indexed</code> by constructing
<code>wd_</code> with <code>wd</code> and <code>index_</code> with <code>index</code>.
</p>
</blockquote>

<pre>
constexpr weekday weekday_indexed::weekday() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_</code>.
</p>
</blockquote>

<pre>
constexpr unsigned weekday_indexed::index() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>index_</code>.
</p>
</blockquote>

<pre>
constexpr bool weekday_indexed::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_.ok() &amp;&amp; 1 &lt;= index_ && index_ &lt;= 5</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const weekday_indexed&amp; x, const weekday_indexed&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.weekday() == y.weekday() && x.index() == y.index()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const weekday_indexed&amp; x, const weekday_indexed&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const weekday_indexed&amp; wdi);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts
<code>os &lt;&lt; wdi.weekday() &lt;&lt; '[' &lt;&lt; wdi.index() &lt;&lt; ']'</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.7 Class <code>weekday_last</code> [time.calendar.weekday_last]</h4>

<p>
<code>weekday_last</code> represents the last <code>weekday</code> of a month. 
It is most easily constructed by indexing a <code>weekday</code> with <code>last</code>.
</p>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
constexpr auto wdl = sun[last];  // wdl is the last Sunday of an as yet unspecified month
static_assert(wdl.weekday() == sun);
</pre></blockquote>

<p>
&mdash; <i>end example:</i>]
</p>

<pre>
class weekday_last
{
    chrono::weekday wd_;  // exposition only

public:
    explicit constexpr weekday_last(const chrono::weekday&amp; wd) noexcept;

    constexpr chrono::weekday weekday() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const weekday_last&amp; x, const weekday_last&amp; y) noexcept;
constexpr bool operator!=(const weekday_last&amp; x, const weekday_last&amp; y) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const weekday_last&amp; wdl);
</pre>

<p>
<code>weekday_last</code> is a trivially copyable class type.</br>
<code>weekday_last</code> is a standard-layout class type.</br>
<code>weekday_last</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr weekday_last::weekday_last(const chrono::weekday&amp; wd) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday_last</code> by constructing
<code>wd_</code> with <code>wd</code>.
</p>
</blockquote>

<pre>
constexpr weekday weekday_last::weekday() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_</code>.
</p>
</blockquote>

<pre>
constexpr bool weekday_last::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const weekday_last&amp; x, const weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.weekday() == y.weekday()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const weekday_last&amp; x, const weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const weekday_last&amp; wdl);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts
<code>os &lt;&lt; wdi.weekday() &lt;&lt; "[last]"</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.8 Class <code>month_day</code> [time.calendar.month_day]</h4>

<p>
<code>month_day</code> represents a specific <code>day</code> of a specific
<code>month</code>, but with an unspecified <code>year</code>.  One can observe the
different components.  One can assign a new value.  <code>month_day</code> is equality
comparable and less-than comparable.  One can stream out a <code>month_day</code>.
</p>

<pre>
class month_day
{
    chrono::month m_;  // exposition only
    chrono::day   d_;  // exposition only

public:
    month_day() = default;
    constexpr month_day(const chrono::month&amp; m, const chrono::day&amp; d) noexcept;

    constexpr chrono::month month() const noexcept;
    constexpr chrono::day   day()   const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator!=(const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&lt; (const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&gt; (const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&lt;=(const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&gt;=(const month_day&amp; x, const month_day&amp; y) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const month_day&amp; md);
</pre>

<p>
<code>month_day</code> is a trivially copyable class type.</br>
<code>month_day</code> is a standard-layout class type.</br>
<code>month_day</code> is a literal class type.</br>
</p>

<pre>
constexpr month_day::month_day(const chrono::month&amp; m, const chrono::day&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>month_day</code> by constructing
<code>m_</code> with <code>m</code>, and <code>d_</code> with <code>d</code>.
</p>
</blockquote>

<pre>
constexpr month month_day::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr day month_day::day() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>d_</code>.
</p>
</blockquote>

<pre>
constexpr bool month_day::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>true</code> if <code>m_.ok()</code> is true, and if
<code>1d &lt;= d_</code>, and if <code>d_ &lt;=</code> the number of days in month
<code>m_</code>.  For <code>m_ == feb</code> the number of days is considered to be 29.
Otherwise returns <code>false</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.month() == y.month() &amp;&amp; x.day() == y.day()</code>
</p>
</blockquote>

<pre>
constexpr bool operator!=(const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>x.month() &lt; y.month()</code> returns <code>true</code>.  Else
if <code>x.month() &gt; y.month()</code> returns <code>false</code>. Else returns
<code>x.day() &lt; y.day()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const month_day&amp; md);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts
<code>os &lt;&lt; md.month() &lt;&lt; '/' &lt;&lt; md.day()</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.9 Class <code>month_day_last</code> [time.calendar.month_day_last]</h4>

<p>
<code>month_day_last</code> represents the last <code>day</code> of a <code>month</code>.
It is most easily constructed using the expression <code>m/last</code> or
<code>last/m</code>, where <code>m</code> is an expression with type <code>month</code>.
</p>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
constexpr auto mdl = feb/last;  // mdl is the last day of February of an as yet unspecified year
static_assert(mdl.month() == feb);
</pre></blockquote>

<p>
&mdash; <i>end example:</i>]
</p>

<pre>
class month_day_last
{
    chrono::month m_;  // exposition only

public:
    constexpr explicit month_day_last(const chrono::month&amp; m) noexcept;

    constexpr chrono::month month() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator!=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&lt; (const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&gt; (const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&lt;=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&gt;=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const month_day_last&amp; mdl);
</pre>

<p>
<code>month_day_last</code> is a trivially copyable class type.</br>
<code>month_day_last</code> is a standard-layout class type.</br>
<code>month_day_last</code> is a literal class type.</br>
</p>

<pre>
constexpr explicit month_day_last::month_day_last(const chrono::month&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>month_day_last</code> by constructing
<code>m_</code> with <code>m</code>.
</p>
</blockquote>

<pre>
constexpr month month_day_last::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr bool month_day_last::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.month() == y.month()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.month() &lt; y.month()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const month_day_last&amp; mdl);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts
<code>os &lt;&lt; mdl.month() &lt;&lt; "/last"</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.10 Class <code>month_weekday</code> [time.calendar.month_weekday]</h4>

<p>
<code>month_weekday</code> represents the nth <code>weekday</code> of a
<code>month</code>, of an as yet unspecified <code>year</code>.  To do this the
<code>month_weekday</code> stores a <code>month</code> and a <code>weekday_indexed</code>.
</p>

<pre>
class month_weekday
{
    chrono::month           m_;    // exposition only
    chrono::weekday_indexed wdi_;  // exposition only
public:
    constexpr month_weekday(const chrono::month&amp; m, const chrono::weekday_indexed&amp; wdi) noexcept;

    constexpr chrono::month           month()           const noexcept;
    constexpr chrono::weekday_indexed weekday_indexed() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const month_weekday&amp; x, const month_weekday&amp; y) noexcept;
constexpr bool operator!=(const month_weekday&amp; x, const month_weekday&amp; y) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const month_weekday&amp; mwd);
</pre>

<p>
<code>month_weekday</code> is a trivially copyable class type.</br>
<code>month_weekday</code> is a standard-layout class type.</br>
<code>month_weekday</code> is a literal class type.</br>
</p>

<pre>
constexpr month_weekday::month_weekday(const chrono::month&amp; m, const chrono::weekday_indexed&amp; wdi) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>month_weekday</code> by constructing
<code>m_</code> with <code>m</code>, and <code>wdi_</code> with <code>wdi</code>.
</p>
</blockquote>

<pre>
constexpr month month_weekday::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr weekday_indexed month_weekday::weekday_indexed() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wdi_</code>.
</p>
</blockquote>

<pre>
constexpr bool month_weekday::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_.ok() &amp;&amp; wdi_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const month_weekday&amp; x, const month_weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.month() == y.month() &amp;&amp; x.weekday_indexed() == y.weekday_indexed()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const month_weekday&amp; x, const month_weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const month_weekday&amp; mwd);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts
<code>os &lt;&lt; mwd.month() &lt;&lt; '/' &lt;&lt; mwd.weekday_indexed()</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.11 Class <code>month_weekday_last</code> [time.calendar.month_weekday_last]</h4>

<p>
<code>month_weekday_last</code> represents the last <code>weekday</code> of a
<code>month</code>, of an as yet unspecified <code>year</code>.  To do this the
<code>month_weekday_last</code> stores a <code>month</code> and a
<code>weekday_last</code>.
</p>

<pre>
class month_weekday_last
{
    chrono::month        m_;     // exposition only
    chrono::weekday_last wdl_;   // exposition only
public:
    constexpr month_weekday_last(const chrono::month&amp; m,
                                 const chrono::weekday_last&amp; wdl) noexcept;

    constexpr chrono::month        month()        const noexcept;
    constexpr chrono::weekday_last weekday_last() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const month_weekday_last&amp; x, const month_weekday_last&amp; y) noexcept;
constexpr bool operator!=(const month_weekday_last&amp; x, const month_weekday_last&amp; y) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const month_weekday_last&amp; mwdl);
</pre>

<p>
<code>month_weekday_last</code> is a trivially copyable class type.</br>
<code>month_weekday_last</code> is a standard-layout class type.</br>
<code>month_weekday_last</code> is a literal class type.</br>
</p>

<pre>
constexpr month_weekday_last::month_weekday_last(const chrono::month&amp; m,
                                                 const chrono::weekday_last&amp; wdl) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>month_weekday_last</code> by constructing
<code>m_</code> with <code>m</code>, and <code>wdl_</code> with <code>wdl</code>.
</p>
</blockquote>

<pre>
constexpr month month_weekday_last::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr weekday_last month_weekday_last::weekday_last() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wdl_</code>.
</p>
</blockquote>

<pre>
constexpr bool month_weekday_last::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_.ok() &amp;&amp; wdl_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const month_weekday_last&amp; x, const month_weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.month() == y.month() &amp;&amp; x.weekday_last() == y.weekday_last()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const month_weekday_last&amp; x, const month_weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const month_weekday_last&amp; mwdl);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts
<code>os &lt;&lt; mwdl.month() &lt;&lt; '/' &lt;&lt; mwdl.weekday_last()</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.12 Class <code>year_month</code> [time.calendar.year_month]</h4>

<p>
<code>year_month</code> represents a specific <code>month</code> of a specific
<code>year</code>, but with an unspecified <code>day</code>. <code>year_month</code> is a
field-based time point with a resolution of <code>months</code>. One can observe the
different components.  One can assign a new value.  <code>year_month</code> is equality
comparable and less-than comparable.  One can stream out a <code>year_month</code>.
</p>

<pre>
class year_month
{
    chrono::year  y_;  // exposition only
    chrono::month m_;  // exposition only

public:
    year_month() = default;
    constexpr year_month(const chrono::year&amp; y, const chrono::month&amp; m) noexcept;

    constexpr chrono::year  year()  const noexcept;
    constexpr chrono::month month() const noexcept;

    constexpr year_month&amp; operator+=(const months&amp; dm) noexcept;
    constexpr year_month&amp; operator-=(const months&amp; dm) noexcept;
    constexpr year_month&amp; operator+=(const years&amp; dy)  noexcept;
    constexpr year_month&amp; operator-=(const years&amp; dy)  noexcept;

    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator!=(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&lt; (const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&gt; (const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&lt;=(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&gt;=(const year_month&amp; x, const year_month&amp; y) noexcept;

constexpr year_month operator+(const year_month&amp; ym, const months&amp; dm) noexcept;
constexpr year_month operator+(const months&amp; dm, const year_month&amp; ym) noexcept;
constexpr year_month operator-(const year_month&amp; ym, const months&amp; dm) noexcept;
constexpr months operator-(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr year_month operator+(const year_month&amp; ym, const years&amp; dy) noexcept;
constexpr year_month operator+(const years&amp; dy, const year_month&amp; ym) noexcept;
constexpr year_month operator-(const year_month&amp; ym, const years&amp; dy) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const year_month&amp; ym);
</pre>

<p>
<code>year_month</code> is a trivially copyable class type.</br>
<code>year_month</code> is a standard-layout class type.</br>
<code>year_month</code> is a literal class type.</br>
</p>

<pre>
constexpr year_month::year_month(const chrono::year&amp; y, const chrono::month&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month</code> by constructing
<code>y_</code> with <code>y</code>, and <code>m_</code> with <code>m</code>.
</p>
</blockquote>

<pre>
constexpr year year_month::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr month year_month::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr year_month&amp; operator+=(const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + dm</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month&amp; operator-=(const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - dm</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month&amp; operator+=(const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + dy</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month&amp; operator-=(const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - dy</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr bool year_month::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_.ok() &amp;&amp; m_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.month() == y.month()</code>
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>x.year() &lt; y.year()</code> returns <code>true</code>.  Else
if <code>x.year() &gt; y.year()</code> returns <code>false</code>. Else returns
<code>x.month() &lt; y.month()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator+(const year_month& ym, const months& dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> A <code>year_month</code> value <code>z</code> such that
<code>z - ym == dm</code>.
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator+(const months& dm, const year_month& ym) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ym + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator-(const year_month& ym, const months& dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ym + -dm</code>.
</p>
</blockquote>

<pre>
constexpr months operator-(const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of <code>months</code> one must add to <code>y</code> to get
<code>x</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator+(const year_month& ym, const years& dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>(ym.year() + dy) / ym.month()</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator+(const years& dy, const year_month& ym) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ym + dy</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator-(const year_month& ym, const years& dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ym + -dy</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const year_month&amp; ym);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts
<code>os &lt;&lt; ym.year() &lt;&lt; '/' &lt;&lt; ym.month()</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.13 Class <code>year_month_day</code> [time.calendar.year_month_day]</h4>

<p>
<code>year_month_day</code> represents a specific <code>year</code>, <code>month</code>,
and <code>day</code>.  <code>year_month_day</code> is a field-based time point with a
resolution of <code>days</code>.  One can observe each field.  <code>year_month_day</code>
supports <code>years</code> and <code>months</code> oriented arithmetic, but not
<code>days</code> oriented arithmetic.  For the latter, there is a conversion to
<code>sys_days</code> which efficiently supports <code>days</code> oriented arithmetic. 
There is also a conversion <i>from</i> <code>sys_days</code>.
<code>year_month_day</code> is equality and less-than comparable.
</p>

<pre>
class year_month_day
{
    chrono::year  y_;  // exposition only
    chrono::month m_;  // exposition only
    chrono::day   d_;  // exposition only

public:
    year_month_day() = default;
    constexpr year_month_day(const chrono::year&amp; y, const chrono::month&amp; m, const chrono::day&amp; d) noexcept;
    constexpr year_month_day(const year_month_day_last&amp; ymdl) noexcept;
    constexpr year_month_day(const sys_days&amp; dp) noexcept;
    constexpr explicit year_month_day(const local_days&amp; dp) noexcept;

    constexpr year_month_day&amp; operator+=(const months&amp; m) noexcept;
    constexpr year_month_day&amp; operator-=(const months&amp; m) noexcept;
    constexpr year_month_day&amp; operator+=(const years&amp; y)  noexcept;
    constexpr year_month_day&amp; operator-=(const years&amp; y)  noexcept;

    constexpr chrono::year  year()  const noexcept;
    constexpr chrono::month month() const noexcept;
    constexpr chrono::day   day()   const noexcept;

    constexpr          operator sys_days()   const noexcept;
    constexpr explicit operator local_days() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator!=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&lt; (const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&gt; (const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&lt;=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&gt;=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;

constexpr year_month_day operator+(const year_month_day&amp; ymd, const months&amp; dm) noexcept;
constexpr year_month_day operator+(const months&amp; dm, const year_month_day&amp; ymd) noexcept;
constexpr year_month_day operator+(const year_month_day&amp; ymd, const years&amp; dy) noexcept;
constexpr year_month_day operator+(const years&amp; dy, const year_month_day&amp; ymd) noexcept;
constexpr year_month_day operator-(const year_month_day&amp; ymd, const months&amp; dm) noexcept;
constexpr year_month_day operator-(const year_month_day&amp; ymd, const years&amp; dy) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const year_month_day&amp; ymd);
</pre>

<p>
<code>year_month_day</code> is a trivially copyable class type.</br>
<code>year_month_day</code> is a standard-layout class type.</br>
<code>year_month_day</code> is a literal class type.</br>
</p>

<pre>
constexpr year_month_day::year_month_day(const chrono::year&amp; y, const chrono::month&amp; m, const chrono::day&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_day</code> by constructing
<code>y_</code> with <code>y</code>, <code>m_</code> with <code>m</code>, and,
<code>d_</code> with <code>d</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day::year_month_day(const year_month_day_last&amp; ymdl) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_day</code> by constructing
<code>y_</code> with <code>ymdl.year()</code>, <code>m_</code> with
<code>ymdl.month()</code>, and, <code>d_</code> with <code>ymdl.day()</code>.
</p>
<p>
<i>Note:</i> This conversion from <code>year_month_day_last</code> to
<code>year_month_day</code> is more efficient than converting a
<code>year_month_day_last</code> to a <code>sys_days</code>, and then converting that
<code>sys_days</code> to a <code>year_month_day</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day::year_month_day(const sys_days&amp; dp) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_day</code> which corresponds
to the date represented by <code>dp</code>.
</p>
<p>
<i>Remarks:</i> For any value of <code>year_month_day</code>, <code>ymd</code>, for which
<code>ymd.ok()</code> is <code>true</code>, this equality will also be <code>true</code>:
<code>ymd == year_month_day{sys_days{ymd}}</code>.
</p>
</blockquote>

<pre>
constexpr explicit year_month_day::year_month_day(const local_days&amp; dp) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_day</code> which corresponds
to the date represented by <code>dp</code>.
</p>
<p>
<i>Remarks:</i> Equivalent to constructing with <code>sys_days{dp.time_since_epoch()}</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day&amp; year_month_day::operator+=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day&amp; year_month_day::operator-=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day&amp; year_month_day::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day&amp; year_month_day::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year year_month_day::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr month year_month_day::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr day year_month_day::day() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>d_</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day::operator sys_days() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>sys_days</code> which represents the date represented by
<code>*this</code>.
</p>
<p>
<i>Remarks:</i> A <code>sys_days</code> which is converted to a <code>year_month_day</code>,
shall have the same value when converted back to a <code>sys_days</code>.  The round
trip conversion sequence shall be <i>loss-less</i>.
</p>
</blockquote>

<pre>
constexpr explicit year_month_day::operator local_days() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>local_days</code> which represents the date represented by
<code>*this</code>.
</p>
<p>
<i>Remarks:</i> Shall return a value equivalent to
<code>local_days{static_cast&lt;sys_days&gt;(*this).time_since_epoch()}</code>.
</p>
</blockquote>

<pre>
constexpr bool year_month_day::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>y_.ok()</code> is <code>true</code>, and <code>m_.ok()</code> is
<code>true</code>, and <code>d_</code> is in the range
<code>[1d, (y_/m_/last).day()]</code>, then returns <code>true</code>, else returns
<code>false</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.month() == y.month() &amp;&amp; x.day() == y.day()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>x.year() &lt; y.year()</code>, returns <code>true</code>.  Else
if <code>x.year() &gt; y.year()</code> returns <code>false</code>.
Else if <code>x.month() &lt; y.month()</code>, returns <code>true</code>.
Else if <code>x.month() &gt; y.month()</code>, returns <code>false</code>.
Else returns <code>x.day() &lt; y.day()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator+(const year_month_day&amp; ymd, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ymd.month().ok()</code> is <code>true</code>.
</p>
<p>
<i>Returns:</i> <code>(ymd.year() / ymd.month() + dm) / ymd.day()</code>.
</p>
<p>
<i>Remarks:</i> If <code>ymd.day()</code> is in the range <code>[1d, 28d]</code>,
the resultant <code>year_month_day</code> is guaranteed to return <code>true</code> from
<code>ok()</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator+(const months&amp; dm, const year_month_day&amp; ymd) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymd + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator-(const year_month_day&amp; ymd, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymd + (-dm)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator+(const year_month_day&amp; ymd, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>(ymd.year() + dy) / ymd.month() / ymd.day()</code>.
</p>
<p>
<i>Remarks:</i> If <code>ymd.month()</code> is <code>feb</code> and <code>ymd.day()</code>
is not in the range <code>[1d, 28d]</code>, the resultant <code>year_month_day</code> is
not guaranteed to return <code>true</code> from <code>ok()</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator+(const years&amp; dy, const year_month_day&amp; ymd) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymd + dy</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator-(const year_month_day&amp; ymd, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymd + (-dy)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const year_month_day&amp; ymd);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts <code>yyyy-mm-dd</code> where the number of indicated digits
are prefixed with <code>'0'</code> if necessary.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.14 Class <code>year_month_day_last</code> [time.calendar.year_month_day_last]</h4>

<p>
<code>year_month_day_last</code> represents a specific <code>year</code>,
<code>month</code>, and the last <code>day</code> of the <code>month</code>.
<code>year_month_day_last</code> is a field-based time point with a resolution of
<code>days</code>, except that it is restricted to pointing to the last day of a year and
month.  One can observe each field.  The <code>day</code> field is computed on demand.
<code>year_month_day_last</code> supports <code>years</code> and <code>months</code>
oriented arithmetic, but not <code>days</code> oriented arithmetic. For the latter, there
is a conversion to <code>sys_days</code> which efficiently supports <code>days</code>
oriented arithmetic.  <code>year_month_day_last</code> is equality and less-than
comparable.
</p>

<pre>
class year_month_day_last
{
    chrono::year           y_;    // exposition only
    chrono::month_day_last mdl_;  // exposition only

public:
    constexpr year_month_day_last(const chrono::year&amp; y,
                                  const chrono::month_day_last&amp; mdl) noexcept;

    constexpr year_month_day_last&amp; operator+=(const months&amp; m) noexcept;
    constexpr year_month_day_last&amp; operator-=(const months&amp; m) noexcept;
    constexpr year_month_day_last&amp; operator+=(const years&amp; y)  noexcept;
    constexpr year_month_day_last&amp; operator-=(const years&amp; y)  noexcept;

    constexpr chrono::year           year()           const noexcept;
    constexpr chrono::month          month()          const noexcept;
    constexpr chrono::month_day_last month_day_last() const noexcept;
    constexpr chrono::day            day()            const noexcept;

    constexpr          operator sys_days()   const noexcept;
    constexpr explicit operator local_days() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator!=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&lt; (const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&gt; (const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&lt;=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&gt;=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;

constexpr year_month_day_last operator+(const year_month_day_last&amp; ymdl, const months&amp; dm) noexcept;
constexpr year_month_day_last operator+(const months&amp; dm, const year_month_day_last&amp; ymdl) noexcept;
constexpr year_month_day_last operator+(const year_month_day_last&amp; ymdl, const years&amp; dy) noexcept;
constexpr year_month_day_last operator+(const years&amp; dy, const year_month_day_last&amp; ymdl) noexcept;
constexpr year_month_day_last operator-(const year_month_day_last&amp; ymdl, const months&amp; dm) noexcept;
constexpr year_month_day_last operator-(const year_month_day_last&amp; ymdl, const years&amp; dy) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const year_month_day_last&amp; ymdl);
</pre>

<p>
<code>year_month_day_last</code> is a trivially copyable class type.</br>
<code>year_month_day_last</code> is a standard-layout class type.</br>
<code>year_month_day_last</code> is a literal class type.</br>
</p>

<pre>
constexpr year_month_day_last::year_month_day_last(const chrono::year&amp; y,
                                                   const chrono::month_day_last&amp; mdl) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_day_last</code> by
constructing <code>y_</code> with <code>y</code> and <code>mdl_</code> with <code>mdl</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last&amp; year_month_day_last::operator+=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last&amp; year_month_day_last::operator-=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last&amp; year_month_day_last::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last&amp; year_month_day_last::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year year_month_day_last::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr month year_month_day_last::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>mdl_.month()</code>.
</p>
</blockquote>

<pre>
constexpr month_day_last year_month_day_last::month_day_last() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>mdl_</code>.
</p>
</blockquote>

<pre>
constexpr day year_month_day_last::day() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> A <code>day</code> representing the last day of the <code>year</code>,
<code>month</code> pair represented by <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last::operator sys_days() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>sys_days</code> which represents the date represented by
<code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit year_month_day_last::operator local_days() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>local_days</code> which represents the date represented by
<code>*this</code>.
</p>
<p>
<i>Remarks:</i> Shall return a value equivalent to
<code>local_days{static_cast&lt;sys_days&gt;(*this).time_since_epoch()}</code>.
</p>
</blockquote>

<pre>
constexpr bool year_month_day_last::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_.ok() &amp;&amp; mdl_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.month_day_last() == y.month_day_last()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>x.year() &lt; y.year()</code>, returns <code>true</code>.  Else
if <code>x.year() &gt; y.year()</code> returns <code>false</code>.
Else returns <code>x.month_day_last() &lt; y.month_day_last()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator+(const year_month_day_last&amp; ymdl, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ymdl.ok()</code> is <code>true</code>.
</p>
<p>
<i>Returns:</i> <code>(ymdl.year() / ymdl.month() + dm) / last</code>.
</p>
<p>
<i>Postconditions:</i> The resultant <code>year_month_day_last</code> will return
<code>true</code> from <code>ok()</code>.
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator+(const months&amp; dm, const year_month_day_last&amp; ymdl) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymdl + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator-(const year_month_day_last&amp; ymdl, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymdl + (-dm)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator+(const year_month_day_last&amp; ymdl, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>{ymdl.year()+dy, ymdl.month_day_last()}</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator+(const years&amp; dy, const year_month_day_last&amp; ymdl) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymdl + dy</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator-(const year_month_day_last&amp; ymdl, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymdl + (-dy)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const year_month_day_last&amp; ymdl);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts
<code>os &lt;&lt; ymdl.year() &lt;&lt; '/' &lt;&lt; ymdl.month_day_last()</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.15 Class <code>year_month_weekday</code> [time.calendar.year_month_weekday]</h4>

<p>
<code>year_month_weekday</code> represents a specific <code>year</code>,
<code>month</code>, and nth <code>weekday</code> of the <code>month</code>. 
<code>year_month_weekday</code> is a field-based time point with a resolution of
<code>days</code>.  One can observe each field. <code>year_month_weekday</code> supports
<code>years</code> and <code>months</code> oriented arithmetic, but not <code>days</code>
oriented arithmetic. For the latter, there is a conversion to <code>sys_days</code> which
efficiently supports <code>days</code> oriented arithmetic. 
<code>year_month_weekday</code> is equality comparable.
</p>

<pre>
class year_month_weekday
{
    chrono::year            y_;    // exposition only
    chrono::month           m_;    // exposition only
    chrono::weekday_indexed wdi_;  // exposition only

public:
    year_month_weekday() = default;
    constexpr year_month_weekday(const chrono::year&amp; y, const chrono::month&amp; m,
                                 const chrono::weekday_indexed&amp; wdi) noexcept;
    constexpr year_month_weekday(const sys_days&amp; dp) noexcept;
    constexpr explicit year_month_weekday(const local_days&amp; dp) noexcept;

    constexpr year_month_weekday&amp; operator+=(const months&amp; m) noexcept;
    constexpr year_month_weekday&amp; operator-=(const months&amp; m) noexcept;
    constexpr year_month_weekday&amp; operator+=(const years&amp; y)  noexcept;
    constexpr year_month_weekday&amp; operator-=(const years&amp; y)  noexcept;

    constexpr chrono::year            year()            const noexcept;
    constexpr chrono::month           month()           const noexcept;
    constexpr chrono::weekday         weekday()         const noexcept;
    constexpr unsigned                index()           const noexcept;
    constexpr chrono::weekday_indexed weekday_indexed() const noexcept;

    constexpr          operator sys_days()   const noexcept;
    constexpr explicit operator local_days() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const year_month_weekday&amp; x, const year_month_weekday&amp; y) noexcept;
constexpr bool operator!=(const year_month_weekday&amp; x, const year_month_weekday&amp; y) noexcept;

constexpr year_month_weekday operator+(const year_month_weekday&amp; ymwd, const months&amp; dm) noexcept;
constexpr year_month_weekday operator+(const months&amp; dm, const year_month_weekday&amp; ymwd) noexcept;
constexpr year_month_weekday operator+(const year_month_weekday&amp; ymwd, const years&amp; dy) noexcept;
constexpr year_month_weekday operator+(const years&amp; dy, const year_month_weekday&amp; ymwd) noexcept;
constexpr year_month_weekday operator-(const year_month_weekday&amp; ymwd, const months&amp; dm) noexcept;
constexpr year_month_weekday operator-(const year_month_weekday&amp; ymwd, const years&amp; dy) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const year_month_weekday&amp; ymwdi);
</pre>

<p>
<code>year_month_weekday</code> is a trivially copyable class type.</br>
<code>year_month_weekday</code> is a standard-layout class type.</br>
<code>year_month_weekday</code> is a literal class type.</br>
</p>

<pre>
constexpr year_month_weekday::year_month_weekday(const chrono::year&amp; y, const chrono::month&amp; m,
                                                 const chrono::weekday_indexed&amp; wdi) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_weekday</code> by
constructing <code>y_</code> with <code>y</code>, <code>m_</code> with <code>m</code>,
and <code>wdi_</code> with <code>wdi</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday(const sys_days&amp; dp) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_weekday</code> which
corresponds to the date represented by <code>dp</code>.
</p>
<p>
<i>Remarks:</i> For any value of <code>year_month_weekday</code>, <code>ymdl</code>, for
which <code>ymdl.ok()</code> is <code>true</code>, this equality will also be
<code>true</code>: <code>ymdl == year_month_weekday{sys_days{ymdl}}</code>.
</p>
</blockquote>

<pre>
constexpr explicit year_month_weekday(const local_days&amp; dp) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_weekday</code> which
corresponds to the date represented by <code>dp</code>.
</p>
<p>
<i>Remarks:</i> Equivalent to constructing with <code>sys_days{dp.time_since_epoch()}</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday&amp; year_month_weekday::operator+=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday&amp; year_month_weekday::operator-=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday&amp; year_month_weekday::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday&amp; year_month_weekday::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year year_month_weekday::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr month year_month_weekday::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr weekday year_month_weekday::weekday() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wdi_.weekday()</code>.
</p>
</blockquote>

<pre>
constexpr unsigned year_month_weekday::index() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wdi_.index()</code>.
</p>
</blockquote>

<pre>
constexpr weekday_indexed year_month_weekday::weekday_indexed() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wdi_</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday::operator sys_days() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>sys_days</code> which represents the date represented by
<code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit year_month_weekday::operator local_days() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>local_days</code> which represents the date represented by
<code>*this</code>.
</p>
<p>
<i>Remarks:</i> Shall return a value equivalent to
<code>local_days{static_cast&lt;sys_days&gt;(*this).time_since_epoch()}</code>.
</p>
</blockquote>

<pre>
constexpr bool year_month_weekday::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>y_.ok()</code> or <code>m_.ok()</code> or <code>wdi_.ok()</code>
returns <code>false</code>, returns <code>false</code>.  Else if <code>*this</code>
represents a valid date, returns <code>true</code>, else returns <code>false</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_month_weekday&amp; x, const year_month_weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.month() == y.month() &amp;&amp; x.weekday_indexed() == y.weekday_indexed()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_month_weekday&amp; x, const year_month_weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator+(const year_month_weekday&amp; ymwd, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ymwd.ok()</code> is <code>true</code>.
</p>
<p>
<i>Returns:</i> <code>(ymwd.year() / ymwd.month() + dm) / ymwd.weekday_indexed()</code>.
</p>
<p>
<i>Postconditions:</i> The resultant <code>year_month_weekday</code> will return
<code>true</code> from <code>ok()</code>.
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator+(const months&amp; dm, const year_month_weekday&amp; ymwd) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwd + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator-(const year_month_weekday&amp; ymwd, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwd + (-dm)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator+(const year_month_weekday&amp; ymwd, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>{ymwd.year()+dy, ymwd.month(), ymwd.weekday_indexed()}</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator+(const years&amp; dy, const year_month_weekday&amp; ymwd) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwd + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator-(const year_month_weekday&amp; ymwd, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwd + (-dm)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const year_month_weekday&amp; ymwd);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts
<code>os &lt;&lt; ymwdi.year() &lt;&lt; '/' &lt;&lt; ymwdi.month() &lt;&lt; '/' &lt;&lt; ymwdi.weekday_indexed()</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.16 Class <code>year_month_weekday_last</code> [time.calendar.year_month_weekday_last]</h4>

<p>
<code>year_month_weekday_last</code> represents a specific <code>year</code>,
<code>month</code>, and last <code>weekday</code> of the <code>month</code>.
<code>year_month_weekday_last</code> is a field-based time point with a resolution of
<code>days</code>, except that it is restricted to pointing to the last weekday of a year
and month.  One can observe each field. <code>year_month_weekday_last</code> supports
<code>years</code> and <code>months</code> oriented arithmetic, but not <code>days</code>
oriented arithmetic. For the latter, there is a conversion to <code>sys_days</code> which
efficiently supports <code>days</code> oriented arithmetic.
<code>year_month_weekday_last</code> is equality comparable.
</p>

<pre>
class year_month_weekday_last
{
    chrono::year         y_;    // exposition only
    chrono::month        m_;    // exposition only
    chrono::weekday_last wdl_;  // exposition only

public:
    constexpr year_month_weekday_last(const chrono::year&amp; y, const chrono::month&amp; m,
                                      const chrono::weekday_last&amp; wdl) noexcept;

    constexpr year_month_weekday_last&amp; operator+=(const months&amp; m) noexcept;
    constexpr year_month_weekday_last&amp; operator-=(const months&amp; m) noexcept;
    constexpr year_month_weekday_last&amp; operator+=(const years&amp; y)  noexcept;
    constexpr year_month_weekday_last&amp; operator-=(const years&amp; y)  noexcept;

    constexpr chrono::year         year()         const noexcept;
    constexpr chrono::month        month()        const noexcept;
    constexpr chrono::weekday      weekday()      const noexcept;
    constexpr chrono::weekday_last weekday_last() const noexcept;

    constexpr          operator sys_days()   const noexcept;
    constexpr explicit operator local_days() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr
bool
operator==(const year_month_weekday_last&amp; x, const year_month_weekday_last&amp; y) noexcept;

constexpr
bool
operator!=(const year_month_weekday_last&amp; x, const year_month_weekday_last&amp; y) noexcept;

constexpr
year_month_weekday_last
operator+(const year_month_weekday_last&amp; ymwdl, const months&amp; dm) noexcept;

constexpr
year_month_weekday_last
operator+(const months&amp; dm, const year_month_weekday_last&amp; ymwdl) noexcept;

constexpr
year_month_weekday_last
operator+(const year_month_weekday_last&amp; ymwdl, const years&amp; dy) noexcept;

constexpr
year_month_weekday_last
operator+(const years&amp; dy, const year_month_weekday_last&amp; ymwdl) noexcept;

constexpr
year_month_weekday_last
operator-(const year_month_weekday_last&amp; ymwdl, const months&amp; dm) noexcept;

constexpr
year_month_weekday_last
operator-(const year_month_weekday_last&amp; ymwdl, const years&amp; dy) noexcept;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const year_month_weekday_last&amp; ymwdl);
</pre>

<p>
<code>year_month_weekday_last</code> is a trivially copyable class type.</br>
<code>year_month_weekday_last</code> is a standard-layout class type.</br>
<code>year_month_weekday_last</code> is a literal class type.</br>
</p>

<pre>
constexpr year_month_weekday_last::year_month_weekday_last(const chrono::year&amp; y, const chrono::month&amp; m,
                                                           const chrono::weekday_last&amp; wdl) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_weekday_last</code> by
constructing <code>y_</code> with <code>y</code>, <code>m_</code> with <code>m</code>,
and <code>wdl_</code> with <code>wdl</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last&amp; year_month_weekday_last::operator+=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last&amp; year_month_weekday_last::operator-=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last&amp; year_month_weekday_last::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last&amp; year_month_weekday_last::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year year_month_weekday_last::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr month year_month_weekday_last::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr weekday year_month_weekday_last::weekday() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wdl_.weekday()</code>.
</p>
</blockquote>

<pre>
constexpr weekday_last year_month_weekday_last::weekday_last() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wdl_</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last::operator sys_days() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>sys_days</code> which represents the date represented by
<code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit year_month_weekday_last::operator local_days() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>local_days</code> which represents the date represented by
<code>*this</code>.
</p>
<p>
<i>Remarks:</i> Shall return a value equivalent to
<code>local_days{static_cast&lt;sys_days&gt;(*this).time_since_epoch()}</code>.
</p>
</blockquote>

<pre>
constexpr bool year_month_weekday_last::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>y_.ok() &amp;&amp; m_.ok() &amp;&amp; wdl_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_month_weekday_last&amp; x, const year_month_weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.month() == y.month() &amp;&amp; x.weekday_last() == y.weekday_last()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_month_weekday_last&amp; x, const year_month_weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator+(const year_month_weekday_last&amp; ymwdl, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ymwdl.ok()</code> is <code>true</code>.
</p>
<p>
<i>Returns:</i> <code>(ymwdl.year() / ymwdl.month() + dm) / ymwdl.weekday_last()</code>.
</p>
<p>
<i>Postconditions:</i> The resultant <code>year_month_weekday_last</code> will return
<code>true</code> from <code>ok()</code>.
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator+(const months&amp; dm, const year_month_weekday_last&amp; ymwdl) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwdl + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator-(const year_month_weekday_last&amp; ymwdl, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwdl + (-dm)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator+(const year_month_weekday_last&amp; ymwdl, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>{ymwdl.year()+dy, ymwdl.month(), ymwdl.weekday_last()}</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator+(const years&amp; dy, const year_month_weekday_last&amp; ymwdl) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwdl + dy</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator-(const year_month_weekday_last&amp; ymwdl, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwdl + (-dy)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const year_month_weekday_last&amp; ymwdl);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts
<code>os &lt;&lt; ymwdl.year() &lt;&lt; '/' &lt;&lt; ymwdl.month() &lt;&lt; '/' &lt;&lt; ymwdl.weekday_last()</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.8.17 civil calendar conventional syntax operators [time.calendar.operators]</h4>

<p>
A set of overloaded <code>operator/()</code> provide a conventional syntax for the
creation of civil calendar dates.  The year, month and day ordering are accepted in
any of the following 3 orders:
</p>

<ol>
<li><code>y/m/d</code></li>
<li><code>m/d/y</code></li>
<li><code>d/m/y</code></li>
</ol>

<p>
Anywhere a "day" is required one can also specify one of:
</p>

<ul>
<li><code>last</code></li>
<li><code>weekday[i]</code></li>
<li><code>weekday[last]</code></li>
</ul>

<p>
Partial-date-types such as <code>year_month</code> and <code>month_day</code> can be created
by simply not applying the second division operator for any of the three orders.  For
example:
</p>

<blockquote><pre>
year_month ym = 2015y/apr;
month_day md1 = apr/4;
month_day md2 = 4d/apr;
</pre></blockquote>

<p>
Everything not intended as above is caught as a compile-time error, with the notable
exception of an expression that consists of nothing but <code>int</code>, which of course
has type <code>int</code>.
</p>

<blockquote><pre>
auto a = 2015/4/4;       // a == int(125)
auto b = 2015y/4/4;      // b == year_month_day{year(2015), month(4), day(4)}
auto c = 2015y/4d/apr;   // error: invalid operands to binary expression ('chrono::year' and 'chrono::day')
auto d = 2015/apr/4;     // error: invalid operands to binary expression ('int' and 'const chrono::month')
</pre></blockquote>

<p>
The last example may be clear to a human reader.  But the compiler doesn't know if
<code>2015</code> refers to a <code>year</code> or a <code>day</code>.  Instead of
guessing, the compiler flags it as an error.
</p>

<p><b><code>year_month</code>:</b></p>

<pre>
constexpr year_month operator/(const year&amp; y, const month&amp; m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{y, m}</code>.
</blockquote>

<pre>
constexpr year_month operator/(const year&amp; y, int   m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / month(m)</code>.
</blockquote>

<p><b><code>month_day</code>:</b></p>

<pre>
constexpr month_day operator/(const month&amp; m, const day&amp; d) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{m, d}</code>.
</blockquote>

<pre>
constexpr month_day operator/(const month&amp; m, int d) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>m / day(d)</code>.
</blockquote>

<pre>
constexpr month_day operator/(int m, const day&amp; d) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / d</code>.
</blockquote>

<pre>
constexpr month_day operator/(const day&amp; d, const month&amp; m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>m / d</code>.
</blockquote>

<pre>
constexpr month_day operator/(const day&amp; d, int m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / d</code>.
</blockquote>

<p><b><code>month_day_last</code>:</b></p>

<pre>
constexpr month_day_last operator/(const month&amp; m, last_spec) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month_day_last{m}</code>.
</blockquote>

<pre>
constexpr month_day_last operator/(int m, last_spec) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / last</code>.
</blockquote>

<pre>
constexpr month_day_last operator/(last_spec, const month&amp; m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>m / last</code>.
</blockquote>

<pre>
constexpr month_day_last operator/(last_spec, int m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / last</code>.
</blockquote>

<p><b><code>month_weekday</code>:</b></p>

<pre>
constexpr month_weekday operator/(const month&amp; m, const weekday_indexed&amp; wdi) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{m, wdi}</code>.
</blockquote>

<pre>
constexpr month_weekday operator/(int m, const weekday_indexed&amp; wdi) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / wdi</code>.
</blockquote>

<pre>
constexpr month_weekday operator/(const weekday_indexed&amp; wdi, const month&amp; m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>m / wdi</code>.
</blockquote>

<pre>
constexpr month_weekday operator/(const weekday_indexed&amp; wdi, int m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / wdi</code>.
</blockquote>

<p><b><code>month_weekday_last</code>:</b></p>

<pre>
constexpr month_weekday_last operator/(const month&amp; m, const weekday_last&amp; wdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{m, wdl}</code>.
</blockquote>

<pre>
constexpr month_weekday_last operator/(int m, const weekday_last&amp; wdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / wdl</code>.
</blockquote>

<pre>
constexpr month_weekday_last operator/(const weekday_last&amp; wdl, const month&amp; m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>m / wdl</code>.
</blockquote>

<pre>
constexpr month_weekday_last operator/(const weekday_last&amp; wdl, int m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / wdl</code>.
</blockquote>

<p><b><code>year_month_day</code>:</b></p>

<pre>
constexpr year_month_day operator/(const year_month&amp; ym, const day&amp; d) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{ym.year(), ym.month(), d}</code>.
</blockquote>

<pre>
constexpr year_month_day operator/(const year_month&amp; ym, int d) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>ym / day(d)</code>.
</blockquote>

<pre>
constexpr year_month_day operator/(const year&amp; y, const month_day&amp; md) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / md.month() / md.day()</code>.
</blockquote>

<pre>
constexpr year_month_day operator/(int y, const month_day&amp; md) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / md</code>.
</blockquote>

<pre>
constexpr year_month_day operator/(const month_day&amp; md, const year&amp; y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / md</code>.
</blockquote>

<pre>
constexpr year_month_day operator/(const month_day&amp; md, int y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / md</code>.
</blockquote>

<p><b><code>year_month_day_last</code>:</b></p>

<pre>
constexpr year_month_day_last operator/(const year_month&amp; ym, last_spec) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{ym.year(), month_day_last{ym.month()}}</code>.
</blockquote>

<pre>
constexpr year_month_day_last operator/(const year&amp; y, const month_day_last&amp; mdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{y, mdl}</code>.
</blockquote>

<pre>
constexpr year_month_day_last operator/(int y, const month_day_last&amp; mdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mdl</code>.
</blockquote>

<pre>
constexpr year_month_day_last operator/(const month_day_last&amp; mdl, const year&amp; y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / mdl</code>.
</blockquote>

<pre>
constexpr year_month_day_last operator/(const month_day_last&amp; mdl, int y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mdl</code>.
</blockquote>

<p><b><code>year_month_weekday</code>:</b></p>

<pre>
constexpr year_month_weekday operator/(const year_month&amp; ym, const weekday_indexed&amp; wdi) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{ym.year(), ym.month(), wdi}</code>.
</blockquote>

<pre>
constexpr year_month_weekday operator/(const year&amp; y, const month_weekday&amp; mwd) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{y, mwd.month(), mwd.weekday_indexed()}</code>.
</blockquote>

<pre>
constexpr year_month_weekday operator/(int y, const month_weekday&amp; mwd) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mwd</code>.
</blockquote>

<pre>
constexpr year_month_weekday operator/(const month_weekday&amp; mwd, const year&amp; y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / mwd</code>.
</blockquote>

<pre>
constexpr year_month_weekday operator/(const month_weekday&amp; mwd, int y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mwd</code>.
</blockquote>

<p><b><code>year_month_weekday_last</code>:</b></p>

<pre>
constexpr year_month_weekday_last operator/(const year_month&amp; ym, const weekday_last&amp; wdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{ym.year(), ym.month(), wdl}</code>.
</blockquote>

<pre>
constexpr year_month_weekday_last operator/(const year&amp; y, const month_weekday_last&amp; mwdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{y, mwdl.month(), mwdl.weekday_last()}</code>.
</blockquote>

<pre>
constexpr year_month_weekday_last operator/(int y, const month_weekday_last&amp; mwdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mwdl</code>.
</blockquote>

<pre>
constexpr year_month_weekday_last operator/(const month_weekday_last&amp; mwdl, const year&amp; y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / mwdl</code>.
</blockquote>

<pre>
constexpr year_month_weekday_last operator/(const month_weekday_last&amp; mwdl, int y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mwdl</code>.
</blockquote>

<blockquote class = note><p>
Add new section [time.time_of_day] after 20.17.8 The civil calendar [time.calendar]:
</p></blockquote>

<h3>20.17.9 Class <code>time_of_day</code> [time.time_of_day]</h3>

<p>
The <code>time_of_day</code> class breaks a <code>duration</code> which
represents the time elapsed since midnight, into a "broken" down time such as
hours:minutes:seconds.  The <code>Duration</code> template parameter dictates the
precision to which the time is broken down.  This can vary from a course precision of
hours to a very fine precision of nanoseconds.  <code>time_of_day</code>  is primarily
a formatting tool.
</p>

<pre>
template &lt;class Duration&gt; class time_of_day;
</pre>
<p>
There are 4 specializations of <code>time_of_day</code> to handle four precisions:
</p>

<ol>

<li>
<pre>
time_of_day&lt;hours&gt;
</pre>
<blockquote><p>
This specialization handles hours since midnight.
</p></blockquote>
</li>

<li>
<pre>
time_of_day&lt;minutes&gt;
</pre>
<blockquote><p>
This specialization handles hours:minutes since midnight.
</p></blockquote>
</li>

<li>
<pre>
time_of_day&lt;seconds&gt;
</pre>
<blockquote><p>
This specialization handles hours:minutes:seconds since midnight.
</p></blockquote>
</li>

<li>
<pre>
time_of_day&lt;duration&lt;Rep, Period&gt;&gt;
</pre>
<blockquote><p>
This specialization is restricted to <code>Period</code>s that are shorter than 1
second.  Typical uses are with milliseconds, microseconds and nanoseconds.  This
specialization handles hours:minute:seconds.fractional_seconds since midnight.
</p></blockquote>
</li>

</ol>

<p>
Each specialization of <code>time_of_day</code> is a trivially copyable class type.</br>
Each specialization of <code>time_of_day</code> is a standard-layout class type.</br>
Each specialization of <code>time_of_day</code> is a literal class type.</br>
</p>

<pre>
time_of_day&lt;hours&gt;
{
public:
    using precision = hours;

    constexpr explicit time_of_day(hours since_midnight) noexcept;
    constexpr time_of_day(hours h, unsigned md) noexcept;

    constexpr hours    hours() const noexcept;
    constexpr unsigned mode()  const noexcept;

    constexpr explicit operator  precision()   const noexcept;
    constexpr          precision to_duration() const noexcept;

    void make24() noexcept;
    void make12() noexcept;
};
</pre>

<pre>
constexpr explicit time_of_day&lt;hours&gt;::time_of_day(hours since_midnight) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 24-hour format
corresponding to <code>since_midnight</code> hours after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns the integral number of hours
<code>since_midnight</code> is after 00:00:00.  <code>mode()</code> returns <code>0</code>.
</p>
</blockquote>

<pre>
constexpr time_of_day&lt;hours&gt;::time_of_day(hours h, unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <code>md == am</code> or <code>md == pm</code>.
</p>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 12-hour format
corresponding to <code>h</code> hours after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns <code>h</code>, and <code>mode()</code>
returns <code>md</code>.
</p>
</blockquote>

<pre>
constexpr hours time_of_day&lt;hours&gt;::hours() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored hour of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr unsigned time_of_day&lt;hours&gt;::mode() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> 0 if <code>*this</code> is in 24-hour format.  Otherwise returns
<code>am</code> or <code>pm</code> corresponding to whether this represents a before-noon
time or afternoon time.
</p>
</blockquote>

<pre>
constexpr explicit time_of_day&lt;hours&gt;::operator precision() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of hours since midnight.
</p>
</blockquote>

<pre>
constexpr precision to_duration() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>precision{*this}</code>.
</p>
</blockquote>

<pre>
void time_of_day&lt;hours&gt;::make24() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 12-hour time, converts to a 24-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
void time_of_day&lt;hours&gt;::make12() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 24-hour time, converts to a 12-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const time_of_day&lt;hours&gt;&amp; t);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>t</code> is a 24-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%H00".  "%H" will emit a leading 0 for
hours less than 10.
Else <code>t</code> is a 12-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%I%p" according to the C locale, except
that no leading zero is output for hours less than 10.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
<p>
<i>Example:</i>
</p>
<blockquote><pre>
0100  // 1 in the morning in 24-hour format
1800  // 6 in the evening in 24-hour format
1am   // 1 in the morning in 12-hour format
6pm   // 6 in the evening in 12-hour format
</pre></blockquote>
</blockquote>

<pre>
time_of_day&lt;minutes&gt;
{
public:
    using precision = minutes;

    constexpr explicit time_of_day(minutes since_midnight) noexcept;
    constexpr time_of_day(hours h, minutes m,
                          unsigned md) noexcept;

    constexpr hours    hours()   const noexcept;
    constexpr minutes  minutes() const noexcept;
    constexpr unsigned mode()    const noexcept;

    constexpr explicit operator precision()    const noexcept;
    constexpr          precision to_duration() const noexcept;

    void make24() noexcept;
    void make12() noexcept;
};
</pre>

<pre>
constexpr explicit time_of_day&lt;minutes&gt;::time_of_day(minutes since_midnight) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 24-hour format
corresponding to <code>since_midnight</code> minutes after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns the integral number of hours
<code>since_midnight</code> is after 00:00:00.  <code>minutes()</code> returns the
integral number of minutes <code>since_midnight</code> is after (00:00:00 +
<code>hours()</code>). <code>mode()</code> returns <code>0</code>.
</p>
</blockquote>

<pre>
constexpr time_of_day&lt;minutes&gt;::time_of_day(hours h, minutes m,
                                                               unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <code>md == am</code> or <code>md == pm</code>.
</p>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 12-hour format
corresponding to <code>h</code> hours and <code>m</code> minutes after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns <code>h</code>, <code>minutes()</code>
returns <code>m</code>, and <code>mode()</code> returns <code>md</code>.
</p>
</blockquote>

<pre>
constexpr hours time_of_day&lt;minutes&gt;::hours() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored hour of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr minutes time_of_day&lt;minutes&gt;::minutes() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored minute of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr unsigned time_of_day&lt;minutes&gt;::mode() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> 0 if <code>*this</code> is in 24-hour format.  Otherwise returns
<code>am</code> or <code>pm</code> corresponding to whether this represents a before-noon
time or afternoon time.
</p>
</blockquote>

<pre>
constexpr explicit time_of_day&lt;minutes&gt;::operator precision() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of minutes since midnight.
</p>
</blockquote>

<pre>
constexpr precision to_duration() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>precision{*this}</code>.
</p>
</blockquote>

<pre>
void time_of_day&lt;minutes&gt;::make24() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 12-hour time, converts to a 24-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
void time_of_day&lt;minutes&gt;::make12() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 24-hour time, converts to a 12-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const time_of_day&lt;minutes&gt;&amp; t);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>t</code> is a 24-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%H:%M".  "%H" will emit a leading 0 for
hours less than 10.
Else <code>t</code> is a 12-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%I:%M%p" according to the C locale, except
that no leading zero is output for hours less than 10.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
<p>
<i>Example:</i>
</p>
<blockquote><pre>
01:08   // 1:08 in the morning in 24-hour format
18:15   // 6:15 in the evening in 24-hour format
1:08am  // 1:08 in the morning in 12-hour format
6:15pm  // 6:15 in the evening in 12-hour format
</pre></blockquote>
</blockquote>

<pre>
time_of_day&lt;seconds&gt;
{
public:
    using precision = seconds;

    constexpr explicit time_of_day(seconds since_midnight) noexcept;
    constexpr time_of_day(hours h, minutes m,
                          seconds s, unsigned md) noexcept;

    constexpr hours    hours()   const noexcept;
    constexpr minutes  minutes() const noexcept;
    constexpr seconds  seconds() const noexcept;
    constexpr unsigned mode()    const noexcept;

    constexpr explicit operator  precision()   const noexcept;
    constexpr          precision to_duration() const noexcept;

    void make24() noexcept;
    void make12() noexcept;
};
</pre>

<pre>
constexpr explicit time_of_day&lt;seconds&gt;::time_of_day(seconds since_midnight) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 24-hour format
corresponding to <code>since_midnight</code> seconds after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns the integral number of hours
<code>since_midnight</code> is after 00:00:00.  <code>minutes()</code> returns the
integral number of minutes <code>since_midnight</code> is after (00:00:00 +
<code>hours()</code>). <code>seconds()</code> returns the integral number of seconds
<code>since_midnight</code> is after (00:00:00 + <code>hours()</code> +
<code>minutes()</code>). <code>mode()</code> returns <code>0</code>.
</p>
</blockquote>

<pre>
constexpr time_of_day&lt;seconds&gt;::time_of_day(hours h, minutes m,
                                                               seconds s, unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <code>md == am</code> or <code>md == pm</code>.
</p>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 12-hour format
corresponding to <code>h</code> hours, <code>m</code> minutes, and <code>s</code> seconds
after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns <code>h</code>. <code>minutes()</code>
returns <code>m</code>.  <code>seconds()</code> returns <code>s</code>. 
<code>mode()</code> returns <code>md</code>.
</p>
</blockquote>

<pre>
constexpr hours time_of_day&lt;seconds&gt;::hours() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored hour of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr minutes time_of_day&lt;seconds&gt;::minutes() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored minute of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr seconds time_of_day&lt;seconds&gt;::seconds() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored second of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr unsigned time_of_day&lt;seconds&gt;::mode() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> 0 if <code>*this</code> is in 24-hour format.  Otherwise returns
<code>am</code> or <code>pm</code> corresponding to whether this represents a before-noon
time or afternoon time.
</p>
</blockquote>

<pre>
constexpr explicit time_of_day&lt;seconds&gt;::operator precision() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of seconds since midnight.
</p>
</blockquote>

<pre>
constexpr precision to_duration() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>precision{*this}</code>.
</p>
</blockquote>

<pre>
void time_of_day&lt;seconds&gt;::make24() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 12-hour time, converts to a 24-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
void time_of_day&lt;seconds&gt;::make12() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 24-hour time, converts to a 12-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const time_of_day&lt;seconds&gt;&amp; t);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>t</code> is a 24-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%H:%M%S".  "%H" will emit a leading 0 for
hours less than 10.
Else <code>t</code> is a 12-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%I:%M%S%p" according to the C locale, except
that no leading zero is output for hours less than 10.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
<p>
<i>Example:</i>
</p>
<blockquote><pre>
01:08:03   // 1:08:03 in the morning in 24-hour format
18:15:45   // 6:15:45 in the evening in 24-hour format
1:08:03am  // 1:08:03 in the morning in 12-hour format
6:15:45pm  // 6:15:45 in the evening in 12-hour format
</pre></blockquote>
</blockquote>

<pre>
time_of_day&lt;duration&lt;Rep, Period&gt;&gt;
{
public:
    using precision = duration&lt;Rep, Period&gt;;

    constexpr explicit time_of_day(precision since_midnight) noexcept;
    constexpr time_of_day(hours h, minutes m,
                          seconds s, precision sub_s, unsigned md) noexcept;

    constexpr hours     hours()      const noexcept;
    constexpr minutes   minutes()    const noexcept;
    constexpr seconds   seconds()    const noexcept;
    constexpr precision subseconds() const noexcept;
    constexpr unsigned  mode()       const noexcept;

    constexpr explicit operator  precision()   const noexcept;
    constexpr          precision to_duration() const noexcept;

    void make24() noexcept;
    void make12() noexcept;
};
</pre>

<p>
This specialization shall not exist unless <code>duration&lt;Rep, Period&gt;{1} &lt; 1s</code>.
</p>

<pre>
constexpr explicit time_of_day&lt;duration&lt;Rep, Period&gt;&gt;::time_of_day(precision since_midnight) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 24-hour format
corresponding to <code>since_midnight precision</code> fractional seconds after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns the integral number of hours
<code>since_midnight</code> is after 00:00:00.  <code>minutes()</code> returns the
integral number of minutes <code>since_midnight</code> is after (00:00:00 +
<code>hours()</code>). <code>seconds()</code> returns the integral number of seconds
<code>since_midnight</code> is after (00:00:00 + <code>hours()</code> +
<code>minutes()</code>). <code>subseconds()</code> returns the integral number of
fractional precision seconds <code>since_midnight</code> is after (00:00:00 +
<code>hours()</code> + <code>minutes()</code> + <code>seconds</code>). <code>mode()</code>
returns <code>0</code>.
</p>
</blockquote>

<pre>
constexpr time_of_day&lt;duration&lt;Rep, Period&gt;&gt;::time_of_day(hours h, minutes m,
                                                                       seconds s, precision sub_s,
                                                                       unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <code>md == am</code> or <code>md == pm</code>.
</p>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 12-hour format
corresponding to <code>h</code> hours, <code>m</code> minutes, and <code>s + sub_s</code>
seconds after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns <code>h</code>. <code>minutes()</code>
returns <code>m</code>.  <code>seconds()</code> returns <code>s</code>.
<code>subseconds()</code> returns <code>sub_s</code>. <code>mode()</code> returns
<code>md</code>.
</p>
</blockquote>

<pre>
constexpr hours time_of_day&lt;duration&lt;Rep, Period&gt;&gt;::hours() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored hour of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr minutes time_of_day&lt;duration&lt;Rep, Period&gt;&gt;::minutes() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored minute of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr seconds time_of_day&lt;duration&lt;Rep, Period&gt;&gt;::seconds() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored second of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr
duration&lt;Rep, Period&gt;
time_of_day&lt;duration&lt;Rep, Period&gt;&gt;::subseconds() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored subsecond of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr unsigned time_of_day&lt;duration&lt;Rep, Period&gt;&gt;::mode() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> 0 if <code>*this</code> is in 24-hour format.  Otherwise returns
<code>am</code> or <code>pm</code> corresponding to whether this represents a before-noon
time or afternoon time.
</p>
</blockquote>

<pre>
constexpr explicit time_of_day&lt;duration&lt;Rep, Period&gt;&gt;::operator precision() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of subseconds since midnight.
</p>
</blockquote>

<pre>
constexpr precision to_duration() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>precision{*this}</code>.
</p>
</blockquote>

<pre>
void time_of_day&lt;duration&lt;Rep, Period&gt;&gt;::make24() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 12-hour time, converts to a 24-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
void time_of_day&lt;duration&lt;Rep, Period&gt;&gt;::make12() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 24-hour time, converts to a 12-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const time_of_day&lt;duration&lt;Rep, Period&gt;&gt;&amp; t);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>t</code> is a 24-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%H:%M%S.%s".  "%H" will emit a leading 0 for
hours less than 10.  "%s" is not a <code>strftime</code> code and represents the fractional
seconds.
Else <code>t</code> is a 12-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%I:%M%S.%s%p" according to the C locale, except
that no leading zero is output for hours less than 10.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
<p>
<i>Example:</i>
</p>
<blockquote><pre>
01:08:03.007   // 1:08:03.007 in the morning in 24-hour format (assuming millisecond precision)
18:15:45.123   // 6:15:45.123 in the evening in 24-hour format (assuming millisecond precision)
1:08:03.007am  // 1:08:03.007 in the morning in 12-hour format (assuming millisecond precision)
6:15:45.123pm  // 6:15:45.123 in the evening in 12-hour format (assuming millisecond precision)
</pre></blockquote>
</blockquote>

<h4>20.17.9.1 Helper functions <code>make_time</code> [time.time_of_day.make_time]</h4>

<p>
These helper functions ease the construction of <code>time_of_day</code> objects by
deducing the precision for the <code>time_of_day</code> return type from the argument to
the helper function.
</p>

<pre>
template &lt;class Rep, class Period&gt;
constexpr
time_of_day&lt;duration&lt;Rep, Period&gt;&gt;
make_time(duration&lt;Rep, Period&gt; d) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>time_of_day&lt;duration&lt;Rep, Period&gt;&gt;(d)</code>.
</p>
</blockquote>

<pre>
constexpr
time_of_day&lt;hours&gt;
make_time(hours h, unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>time_of_day&lt;hours&gt;(h, md)</code>.
</p>
</blockquote>

<pre>
constexpr
time_of_day&lt;minutes&gt;
make_time(hours h, minutes m, unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>time_of_day&lt;minutes&gt;(h, m, md)</code>.
</p>
</blockquote>

<pre>
constexpr
time_of_day&lt;seconds&gt;
make_time(hours h, minutes m, seconds s,
          unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>time_of_day&lt;seconds&gt;(h, m, s, md)</code>.
</p>
</blockquote>

<pre>
template &lt;class Rep, class Period,
          class = enable_if_t&lt;ratio_less&lt;Period, ratio&lt;1&gt;&gt;::value&gt;&gt;
constexpr
time_of_day&lt;duration&lt;Rep, Period&gt;&gt;
make_time(hours h, minutes m, seconds s,
          duration&lt;Rep, Period&gt; sub_s, unsigned md) noexcept
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>time_of_day&lt;duration&lt;Rep, Period&gt;&gt;(h, m, s, sub_s, md)</code>.
</p>
</blockquote>

<blockquote class = note><p>
Add new section [time.timezone] after 20.17.9 Class <code>time_of_day</code> [time.time_of_day]:
</p></blockquote>

<h3>20.17.10 Time Zones [time.timezone]</h3>

<p>
This clause creates an API which exposes the IANA Time Zone database, and
interfaces with <code>sys_time</code> and <code>local_time</code>.  By using
only this interface, time zone support is provided not only to the civil
calendar types, but also to other user-written calendars that interface with
<code>sys_time</code> and <code>local_time</code>.
</p>

<h4>20.17.10.1 The time zone database [time.timezone.database]</h4>

<p>
The following data structure is the time zone database, and the following
functions access it.
</p>

<pre>
struct TZ_DB
{
    string            version;
    vector&lt;time_zone&gt; zones;
    vector&lt;link&gt;      links;
    vector&lt;leap&gt;      leaps;
};
</pre>

<p>
The <cod>TZ_DB</code> database is a singleton.  And access to it is
<i>read-only</i>, except for <code>reload_tzdb()</code> which re-initializes it.
Each <code>vector</code> is sorted to enable fast lookup.  You can iterate over
and inspect this database.
</p>

<pre>
const TZ_DB&amp; get_tzdb();
</pre>
<blockquote>
<p>
<i>Effects:</i>  If this is the first access to the database, will initialize
the database.
</p>
<p>
<i>Returns:</i> A <code>const</code> reference to the database.
</p>
<p>
<i>Thread Safety:</i>  It is safe to call this function from multiple threads at
one time.
</p>
<p>
<i>Throws:</i> <code>runtime_error</code> if for any reason a reference can not
be returned to a valid <code>TZ_DB</code>.
</p>
</blockquote>

<pre>
const time_zone* locate_zone(const string&amp; tz_name);
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <code>get_tzdb()</code> which will initialize the timezone
database if this is the first reference to the database.
</p>
<p>
<i>Returns:</i> If a <code>time_zone</code> is found for which
<code>name() == tz_name</code>, returns a pointer to that <code>time_zone</code>.
Otherwise if a <code>link</code> is found where <code>tz_name == link.name()</code>,
then a pointer is returned to the <code>time_zone</code> for which
<code>zone.name() == link.target()</code> [<i>Note:</i> A <code>link</code> is an
alternative name for a <code>time_zone</code>. <i>&mdash; end note</i>]
</p>
<p>
<i>Throws:</i> Any exception propagated from <code>get_tzdb()</code>.  If a
<code>const time_zone*</code> can not be found as described in the
<i>Returns</i> clause, throws a <code>runtime_error</code>. [<i>Note:</i>
On non-exceptional return, the return value is <i>always</i> a pointer to a
valid <code>time_zone</code>. <i>&mdash; end note</i>]
</p>
</blockquote>

<pre>
const time_zone* current_zone();
</pre>
<blockquote>
<i>Effects:</i>  Calls <code>locate_zone()</code> which will initialize the timezone
database if this is the first reference to the database.
</p>
<p>
<i>Returns:</i> A <code>const time_zone*</code> referring to the time zone which your
computer has set as its local time zone.
</p>
<p>
<i>Throws:</i> Any exception propagated from <code>locate_zone()</code>.
[<i>Note:</i> On non-exceptional return, the return value is <i>always</i> a
pointer to a valid <code>time_zone</code>. <i>&mdash; end note</i>]
</blockquote>

<h4>20.17.10.1.1 Remote time zone database support [time.timezone.database.remote]</h4>
<blockquote class = note><p>
This subsection is optional/seperable and needs further discussion in the LEWG.  No
other sections depend upon this subsection.
</p></blockquote>

<pre>
const TZ_DB&amp; reload_tzdb();
</pre>
<blockquote>
<p>
<i>Effects:</i> This function first checks the latest version at the
<a href="http://www.iana.org/time-zones">IANA website</a>.  If the
<a href="http://www.iana.org/time-zones">IANA website</a> is unavailable, or if the
latest version is already installed, there are no effects.  Otherwise, a new version
is available.  It is downloaded and installed, and then the program re-initializes
the <code>TZ_DB</code> singleton from the new disk files.
</p>
<p>
<i>Returns:</i> A <code>const</code> reference to the database.
</p>
<p>
<i>Thread Safety:</i>  This function is <i>not</i> thread safe.  You must
provide your own synchronization among threads accessing the time zone database
to safely use this function.  If this function re-initializes the database, all outstanding
<code>const time_zone*</code> are invalidated (including those held within
<code>zoned_time</code> objects).  And afterwards, all outstanding
<code>sys_info</code> may hold obsolete data.
</p>
<p>
<i>Throws:</i> <code>runtime_error</code> if for any reason a reference can not
be returned to a valid <code>TZ_DB</code>.
</p>
</blockquote>

<pre>
string remote_version();
</pre>
<blockquote>
<p>
<i>Returns:</i> The latest database version number from the
<a href="http://www.iana.org/time-zones">IANA website</a>.  If the
<a href="http://www.iana.org/time-zones">IANA website</a> can not be reached, or
if it can be reached but the latest version number is unexpectedly not
available, the empty string is returned.
</p>
<p>
<i>Note:</i>  If non-empty, this can be compared with <code>get_tzdb().version</code> to
discover if you have the latest database installed.
</p>
</blockquote>

<pre>
bool remote_download(const string&amp; version);
</pre>
<blockquote>
<p>
<i>Effects:</i>  If <code>version == remote_version()</code> this function will download
the compressed tar file holding the latest time zone database from the
<a href="http://www.iana.org/time-zones">IANA website</a>.  The tar file will be placed
at an unspecified location.
</p>
<p>
<i>Returns:</i>  <code>true</code> if the database was successfully downloaded, else
<code>false</code>.
</p>
<p>
<i>Thread safety:</i>  If called by multiple threads, there will be a race on the
creation of the tar file.
</p>
</blockquote>

<pre>
bool remote_install(const string&amp; version);
</pre>
<blockquote>
<p>
<i>Effects:</i>  If <code>version</code> refers to the file successfully
downloaded by <code>remote_download()</code> this function will remove the
existing time zone database, then extract a new database
from the tar file, and will then delete the tar file.
</p>
<p>
This function <i>does not</i> cause your program to re-initialize itself from
this new database.  In order to do that, you must call
<code>reload_tzdb()</code> (or <code>get_tzdb()</code> if the database has yet
to be initialized).
</p>
<p>
<i>Returns:</i>  <code>true</code> if the database was successfully replaced by
the tar file , else <code>false</code>.
</p>
<p>
<i>Thread safety:</i>  If called by multiple threads, there will be a race on the
creation of the new database.
</p>
</blockquote>

<h4>20.17.10.2 Exception classes [time.timezone.exception]</h4>

<p>
<code>nonexistent_local_time</code> is thrown when one attempts to convert a
non-existent <code>local_time</code> to a <code>sys_time</code> without specifying
<code>choose::earliest</code> or <code>choose::latest</code>.
</p>
<pre>
class nonexistent_local_time
    : public runtime_error
{
public:
    // Construction is undocumented
};
</pre>
<p>
[<i>Example:</i>
</p>
<blockquote>
<pre>
#include "tz.h"
#include &lt;iostream&gt;

int
main()
{
    using namespace std::chrono;
    try
    {
        auto zt = make_zoned("America/New_York", local_days{sun[2]/mar/2016} + 2h + 30min);
    }
    catch (const nonexistent_local_time&amp; e)
    {
        std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    }
}
</pre>
<p>
Which outputs:
</p>
<pre>
2016-03-13 02:30:00 is in a gap between
2016-03-13 02:00:00 EST and
2016-03-13 03:00:00 EDT which are both equivalent to
2016-03-13 07:00:00 UTC
</pre>
</blockquote>
<p>
<i>&mdash; end example:</i>]
</p>

<p>
<code>ambiguous_local_time</code> is thrown when one attempts to convert an ambiguous
<code>local_time</code> to a <code>sys_time</code> without specifying
<code>choose::earliest</code> or <code>choose::latest</code>.
</p>
<pre>
class ambiguous_local_time
    : public runtime_error
{
public:
    // Construction is undocumented
};
</pre>
<p>
[<i>Example:</i>
</p>
<blockquote>
<pre>
#include "tz.h"
#include &lt;iostream&gt;

int
main()
{
    using namespace std::chrono;
    try
    {
        auto zt = make_zoned("America/New_York", local_days{sun[1]/nov/2016} + 1h + 30min);
    }
    catch (const ambiguous_local_time&amp; e)
    {
        std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    }
}
</pre>
<p>
Which outputs:
</p>
<pre>
2016-11-06 01:30:00 is ambiguous.  It could be
2016-11-06 01:30:00 EDT == 2016-11-06 05:30:00 UTC or
2016-11-06 01:30:00 EST == 2016-11-06 06:30:00 UTC
</pre>
</blockquote>
<p>
<i>&mdash; end example:</i>]
</p>

<h4>20.17.10.3 Information classes [time.timezone.info]</h4>

<p>
A <code>sys_info</code> structure can be obtained from the combination of a <code>time_zone</code> and
either a <code>sys_time</code>, or <code>local_time</code>.  It can also be obtained
from a <code>zoned_time</code> which is effectively a <code>pair</code> of
a <code>time_zone</code> and <code>sys_time</code>.
</p>
<p>
This structure represents a lower-level API.  Typical conversions from
<code>sys_time</code> to <code>local_time</code> will use this structure
<i>implicitly</i>, not <i>explicitly</i>.
</p>
<pre>
struct sys_info
{
    sys_seconds   begin;
    sys_seconds   end;
    seconds       offset;
    minutes       save;
    string        abbrev;
};
</pre>
<p>
The <code>begin</code> and <code>end</code> fields indicate that for the
associated <code>time_zone</code> and <code>time_point</code>, the
<code>offset</code> and <code>abbrev</code> are in effect in the range
<code>[begin, end)</code>.  This information can be used to efficiently iterate the
transitions of a <code>time_zone</code>.
</p>
<p>
The <code>offset</code> field indicates the UTC offset in effect for the associated
<code>time_zone</code> and <code>time_point</code>.  The relationship between
<code>local_time</code> and <code>sys_time</code> is:
</p>
<pre>
offset = local_time - sys_time
</pre>
<p>
The <code>save</code> field is "extra" information not normally needed for
conversion between <code>local_time</code> and <code>sys_time</code>.  If
<code>save != 0min</code>, this <code>sys_info</code> is said to be on "daylight
saving" time, and <code>offset - save</code> suggests what this
<code>time_zone</code> <i>might</i> use if it were off daylight saving. However
this information should not be taken as authoritative.  The only sure way to get
such information is to query the <code>time_zone</code> with a
<code>time_point</code> that returns an <code>sys_info</code> where
<code>save == 0min</code>.  There is no guarantee what <code>time_point</code> might return such
an <code>sys_info</code> except that it is guaranteed <i>not</i> to be in the range
<code>[begin, end)</code> (if <code>save != 0min</code> for this <code>sys_info</code>).
</p>
<p>
The <code>abbrev</code> field indicates the current abbreviation used for the
associated <code>time_zone</code> and <code>time_point</code>.  Abbreviations
are not unique among the <code>time_zone</code>s, and so one can not reliably
map abbreviations back to a <code>time_zone</code> and UTC offset.
</p>
<p>
A <code>sys_info</code> can be streamed out in an unspecified format:
</p>
<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const sys_info&amp; r);
</pre>
</blockquote>

<p>
A <code>local_info</code> structure represents a lower-level API.  Typical conversions from
<code>local_time</code> to <code>sys_time</code> will use this structure
<i>implicitly</i>, not <i>explicitly</i>.
</p>
<pre>
struct local_info
{
    enum {unique, nonexistent, ambiguous} result;
    sys_info first;
    sys_info second;
};
</pre>
<p>
When a <code>local_time</code> to <code>sys_time</code> conversion is unique,
<code>result == unique</code>, <code>first</code> will be filled out with the
correct <code>sys_info</code> and <code>second</code> will be zero-initialized.
If the conversion stems from a nonexistent <code>local_time</code> then
<code>result == nonexistent</code>, <code>first</code> will be filled out with
the <code>sys_info</code> that ends just prior to the <code>local_time</code>
and <code>second</code> will be filled out with the <code>sys_info</code> that
begins just after the <code>local_time</code>. If the conversion stems from an
ambiguous <code>local_time</code> then <code>result == ambiguous</code>,
<code>first</code> will be filled out with the <code>sys_info</code> that ends
just after the <code>local_time</code> and <code>second</code> will be filled
out with the <code>sys_info</code> that starts just before the
<code>local_time</code>.
</p>
<p>
A <code>local_info</code> can be streamed out in an unspecified format:
</p>
<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const local_info&amp; r);
</pre>

<h4>20.17.10.4 Class <code>time_zone</code> [time.timezone.time_zone]</h4>

<p>
A <code>time_zone</code> represents all time zone transitions for a specific geographic
area.  <code>time_zone</code> construction is undocumented, and done during
the database initialization.  You can gain <code>const</code> access to a
<code>time_zone</code> via functions such as <code>locate_zone</code>.
</p>
<pre>
class time_zone
{
public:
    time_zone(const time_zone&amp;) = delete;
    time_zone&amp; operator=(const time_zone&amp;) = delete;

    const string&amp; name() const;

    template &lt;class Duration&gt; sys_info   get_info(sys_time&lt;Duration&gt; st)   const;
    template &lt;class Duration&gt; local_info get_info(local_time&lt;Duration&gt; tp) const;

    template &lt;class Duration&gt;
        sys_time&lt;typename common_type&lt;Duration, seconds&gt;::type&gt;
        to_sys(local_time&lt;Duration&gt; tp) const;

    template &lt;class Duration&gt;
        sys_time&lt;typename common_type&lt;Duration, seconds&gt;::type&gt;
        to_sys(local_time&lt;Duration&gt; tp, choose z) const;

    template &lt;class Duration&gt;
        local_time&lt;typename common_type&lt;Duration, seconds&gt;::type&gt;
        to_local(sys_time&lt;Duration&gt; tp) const;
};

bool operator==(const time_zone&amp; x, const time_zone&amp; y);
bool operator!=(const time_zone&amp; x, const time_zone&amp; y);
bool operator&lt; (const time_zone&amp; x, const time_zone&amp; y);
bool operator&gt; (const time_zone&amp; x, const time_zone&amp; y);
bool operator&lt;=(const time_zone&amp; x, const time_zone&amp; y);
bool operator&gt;=(const time_zone&amp; x, const time_zone&amp; y);

ostream&amp; operator&lt;&lt;(ostream&amp; os, const time_zone&amp; z)
</pre>
<pre>
const string&amp; time_zone::name() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> The name of the <code>time_zone</code>.
</p>
<p>
<i>Example:</i> "America/New_York".
</p>
<p>
<i>Note:</i> Here is an unofficial list of <code>time_zone</code> names:
<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt; sys_info time_zone::get_info(sys_time&lt;Duration&gt; st) const;
</pre>
<blockquote>
<p>
<i>Returns:</i> A <code>sys_info</code> <code>i</code> for which <code>st</code> is in the
range <code>[i.begin, i.end)</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt; local_info time_zone::get_info(local_time&lt;Duration&gt; tp) const;
</pre>
<blockquote>
<p>
<i>Returns:</i> A <code>local_info</code> for <code>tp</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
sys_time&lt;typename common_type&lt;Duration, seconds&gt;::type&gt;
time_zone::to_sys(local_time&lt;Duration&gt; tp) const;
</pre>
<blockquote>
<p>
<i>Returns:</i> A <code>sys_time</code> that is at least as fine as <code>seconds</code>,
and will be finer if the argument <code>tp</code> has finer precision.  This
<code>sys_time</code> is the UTC equivalent of <code>tp</code> according to the rules
of this <code>time_zone</code>.
</p>
<p>
<i>Throws:</i> If the conversion from <code>tp</code> to a <code>sys_time</code>
is ambiguous, throws <code>ambiguous_local_time</code>.  If the conversion from
<code>tp</code> to a <code>sys_time</code> is nonexistent, throws
<code>nonexistent_local_time</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
sys_time&lt;typename common_type&lt;Duration, seconds&gt;::type&gt;
time_zone::to_sys(local_time&lt;Duration&gt; tp, choose z) const;
</pre>
<blockquote>
<p>
<i>Returns:</i> A <code>sys_time</code> that is at least as fine as
<code>seconds</code>, and will be finer if the argument <code>tp</code> has
finer precision.  This <code>sys_time</code> is the UTC equivalent of
<code>tp</code> according to the rules of this <code>time_zone</code>. If the
conversion from <code>tp</code> to a <code>sys_time</code> is ambiguous, returns
the earlier <code>sys_time</code> if <code>z == choose::earliest</code>, and
returns the later <code>sys_time</code> if <code>z == choose::latest</code>. If
the <code>tp</code> represents a non-existent time between two UTC
<code>time_point</code>s, then the two UTC <code>time_point</code>s will be the
same, and that UTC <code>time_point</code> will be returned.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
local_time&lt;typename common_type&lt;Duration, seconds&gt;::type&gt;
time_zone::to_local(sys_time&lt;Duration&gt; tp) const;
</pre>
<blockquote>
<p>
<i>Returns:</i> The <code>local_time</code> associated with <code>tp</code> and this
<code>time_zone</code>.
</p>
</blockquote>

<pre>
bool operator==(const time_zone&amp; x, const time_zone&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>x.name() == y.name()</code>.
</p>
</blockquote>

<pre>
bool operator!=(const time_zone&amp; x, const time_zone&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
bool operator&lt;(const time_zone&amp; x, const time_zone&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>x.name() &lt; y.name()</code>.
</p>
</blockquote>

<pre>
bool operator&gt;(const time_zone&amp; x, const time_zone&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
bool operator&lt;=(const time_zone&amp; x, const time_zone&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
bool operator&gt;=(const time_zone&amp; x, const time_zone&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const time_zone&amp; z)
</pre>
<blockquote>
<p>
Produces an unspecified output representing the <code>time_zone</code>.
</p>
</blockquote>

<h4>20.17.10.5 Class <code>zoned_time</code> [time.timezone.zoned_time]</h4>

<p>
<code>zoned_time</code> represents a logical paring of <code>time_zone</code> and a
<code>time_point</code> with precision <code>Duration</code>.  If <code>seconds</code>
is not implicitly convertible to <code>Duration</code>, the instantiation is ill-formed.
[<i>Note:</i> There exist <code>time_zone</code>s with UTC offsets that require a
precision of <code>seconds</code>. <i>&mdash; end note:</i>] 
</p>

<pre>
template &lt;class Duration&gt;
class zoned_time
{
    const time_zone*   zone_;  // exposition only
    sys_time&lt;Duration&gt; tp_;    // exposition only

public:
    zoned_time(const zoned_time&amp;) = default;
    zoned_time&amp; operator=(const zoned_time&amp;) = default;

             zoned_time(sys_time&lt;Duration&gt; st);
    explicit zoned_time(const time_zone* z);
    explicit zoned_time(const string&amp; name);

    template &lt;class Duration2&gt;
        zoned_time(const zoned_time&lt;Duration2&gt;&amp; zt) noexcept;

    zoned_time(const time_zone* z, local_time&lt;Duration&gt; tp);
    zoned_time(const string&amp; name, local_time&lt;Duration&gt; tp);
    zoned_time(const time_zone* z, local_time&lt;Duration&gt; tp, choose c);
    zoned_time(const string&amp; name, local_time&lt;Duration&gt; tp, choose c);

    zoned_time(const time_zone* z, const zoned_time&lt;Duration&gt;&amp; zt);
    zoned_time(const string&amp; name, const zoned_time&lt;Duration&gt;&amp; zt);
    zoned_time(const time_zone* z, const zoned_time&lt;Duration&gt;&amp; zt, choose);
    zoned_time(const string&amp; name, const zoned_time&lt;Duration&gt;&amp; zt, choose);

    zoned_time(const time_zone* z, const sys_time&lt;Duration&gt;&amp; st);
    zoned_time(const string&amp; name, const sys_time&lt;Duration&gt;&amp; st);

    zoned_time&amp; operator=(sys_time&lt;Duration&gt; st);
    zoned_time&amp; operator=(local_time&lt;Duration&gt; ut);

             operator sys_time&lt;Duration&gt;()   const;
    explicit operator local_time&lt;Duration&gt;() const;

    const time_zone*     get_time_zone()  const;
    local_time&lt;Duration&gt; get_local_time() const;
    sys_time&lt;Duration&gt;   get_sys_time()   const;
    sys_info             get_info()       const;
};

template &lt;class Duration1, class Duration2&gt;
bool
operator==(const zoned_time&lt;Duration1&gt;&amp; x, const zoned_time&lt;Duration2&gt;&amp; y);

template &lt;class Duration1, class Duration2&gt;
bool
operator!=(const zoned_time&lt;Duration1&gt;&amp; x, const zoned_time&lt;Duration2&gt;&amp; y);
</pre>

<p>
An invariant of <code>zoned_time&lt;Duration&gt;</code> is that it always refers
to a valid <code>time_zone</code>, and represents a point in time that exists
and is not ambiguous.
</p>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const zoned_time&amp;) = default;
zoned_time&lt;Duration&gt;&amp; zoned_time&lt;Duration&gt;::operator=(const zoned_time&amp;) = default;
</pre>
<blockquote>
<p>
The copy members transfer the associated <code>time_zone</code> from the source
to the destination.  After copying, source and destination compare equal.  If
<code>Duration</code> has <code>noexcept</code> copy members, then
<code>zoned_time&lt;Duration&gt;</code> has <code>noexcept</code> copy
members.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(sys_time&lt;Duration&gt; st);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs a <code>zoned_time</code> <code>zt</code> such that
<code>zt.get_time_zone()-&gt;name() == "UTC"</code>, and
<code>zt.get_sys_time() == st</code>.
</p>
</blockquote>

<pre>
explicit zoned_time&lt;Duration&gt;::zoned_time(const time_zone* z);
</pre>
<blockquote>
<p>
<i>Requires:</i> <code>z</code> refers to a valid <code>time_zone</code>.
</p>
<p>
<i>Effects:</i> Constructs a <code>zoned_time</code> <code>zt</code> such that
<code>zt.get_time_zone()-&gt; == z</code>, and
<code>zt.get_sys_time() == sys_seconds{}</code>.
</p>
</blockquote>

<pre>
explicit zoned_time&lt;Duration&gt;::zoned_time(const string&amp; name);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to construction with <code>locate_zone(name)</code>.
</p>
<p>
<i>Throws:</i> Any exception propagating out of <code>locate_zone(name)</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration2&gt;
    zoned_time&lt;Duration&gt;::zoned_time(const zoned_time&lt;Duration2&gt;&amp; y) noexcept;
</pre>
<blockquote>
<p>
<i>Remarks:</i> Does not participate in overload resolution unless
<code>sys_time&lt;Duration2&gt;</code> is implicitly convertible to 
<code>sys_time&lt;Duration&gt;</code>.
</p>
<p>
<i>Effects:</i> Constructs a <code>zoned_time</code> <code>x</code> such that
<code>x == y</code>.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const time_zone* z, local_time&lt;Duration&gt; tp);
</pre>
<blockquote>
<p>
<i>Requires:</i> <code>z</code> refers to a valid <code>time_zone</code>.
</p>
<p>
<i>Effects:</i> Constructs a <code>zoned_time</code> <code>zt</code> such that
<code>zt.get_time_zone()-&gt; == z</code>, and <code>zt.get_local_time() == tp</code>.
</p>
<p>
<i>Throws:</i> Any exception that <code>z-&gt;to_sys(tp)</code> would throw.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const string&amp; name, local_time&lt;Duration&gt; tp);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to construction with <code>{locate_zone(name), tp}</code>.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const time_zone* z, local_time&lt;Duration&gt; tp, choose c);
</pre>
<blockquote>
<p>
<i>Requires:</i> <code>z</code> refers to a valid <code>time_zone</code>.
</p>
<p>
<i>Effects:</i> Constructs a <code>zoned_time</code> <code>zt</code> such that
<code>zt.get_time_zone()-&gt; == z</code>, and
<code>zt.get_sys_time() == z-&gt;to_sys(tp, c)</code>.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const string&amp; name, local_time&lt;Duration&gt; tp, choose c);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to construction with <code>{locate_zone(name), tp, c}</code>.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const time_zone* z, const zoned_time&lt;Duration&gt;&amp; y);
</pre>
<blockquote>
<p>
<i>Requires:</i> <code>z</code> refers to a valid <code>time_zone</code>.
</p>
<p>
<i>Effects:</i> Constructs a <code>zoned_time</code> <code>zt</code> such that
<code>zt.get_time_zone()-&gt; == z</code>, and
<code>zt.get_sys_time() == y.get_sys_time()</code>.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const string&amp; name, const zoned_time&lt;Duration&gt;&amp; y);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to construction with <code>{locate_zone(name), y}</code>.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const time_zone* z, const zoned_time&lt;Duration&gt;&amp; y, choose);
</pre>
<blockquote>
<p>
<i>Requires:</i> <code>z</code> refers to a valid <code>time_zone</code>.
</p>
<p>
<i>Effects:</i> Constructs a <code>zoned_time</code> <code>zt</code> such that
<code>zt.get_time_zone()-&gt; == z</code>, and
<code>zt.get_sys_time() == y.get_sys_time()</code>.
</p>
<p>
<i>Note:</i> The <code>choose</code> parameter is allowed here, but has no impact.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const string&amp; name, const zoned_time&lt;Duration&gt;&amp; y, choose);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to construction with <code>{locate_zone(name), y}</code>.
</p>
<p>
<i>Note:</i> The <code>choose</code> parameter is allowed here, but has no impact.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const time_zone* z, const sys_time&lt;Duration&gt;&amp; st);
</pre>
<blockquote>
<p>
<i>Requires:</i> <code>z</code> refers to a valid <code>time_zone</code>.
</p>
<p>
<i>Effects:</i> Constructs a <code>zoned_time</code> <code>zt</code> such that
<code>zt.get_time_zone()-&gt; == z</code>, and <code>zt.get_sys_time() == st</code>.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::zoned_time(const string&amp; name, const sys_time&lt;Duration&gt;&amp; st);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to construction with <code>{locate_zone(name), st}</code>.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;&amp; zoned_time&lt;Duration&gt;::operator=(sys_time&lt;Duration&gt; st);
</pre>
<blockquote>
<p>
<i>Effects:</i> After assignment <code>get_sys_time() == st</code>.  This assignment has
no effect on the return value of <code>get_time_zone()</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;&amp; zoned_time&lt;Duration&gt;::operator=(local_time&lt;Duration&gt; lt);
</pre>
<blockquote>
<p>
<i>Effects:</i> After assignment <code>get_local_time() == lt</code>.  This assignment has
no effect on the return value of <code>get_time_zone()</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
zoned_time&lt;Duration&gt;::operator sys_time&lt;Duration&gt;() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>get_sys_time()</code>.
</p>
</blockquote>

<pre>
explicit zoned_time&lt;Duration&gt;::operator local_time&lt;Duration&gt;() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>get_local_time()</code>.
</p>
</blockquote>

<pre>
const time_zone* zoned_time&lt;Duration&gt;::get_time_zone() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>zone_</code>.
</p>
</blockquote>

<pre>
local_time&lt;Duration&gt; zoned_time&lt;Duration&gt;::get_local_time() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>zone_-&gt;to_local(tp_)</code>.
</p>
</blockquote>

<pre>
sys_time&lt;Duration&gt; zoned_time&lt;Duration&gt;::get_sys_time() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>tp_</code>.
</p>
</blockquote>

<pre>
sys_info zoned_time&lt;Duration&gt;::get_info() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>zone_-&gt;get_info(tp_)</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration1, class Duration2&gt;
bool
operator==(const zoned_time&lt;Duration1&gt;&amp; x, const zoned_time&lt;Duration2&gt;&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>x.zone_ == y.zone_ &amp;&amp; x.tp_ == y.tp_</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration1, class Duration2&gt;
bool
operator!=(const zoned_time&lt;Duration1&gt;&amp; x, const zoned_time&lt;Duration2&gt;&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
template <class Duration>
ostream&
operator<<(ostream& os, const zoned_time<Duration>& t)
</pre>
<blockquote>
<p>
<i>Effects:</i> Streams <code>t</code> to <code>os</code> using the format "%F %T %Z"
and the value returned from <code>t.get_local_time()</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<h4>20.17.10.6 Helper functions <code>make_zoned</code> [time.timezone.make_zoned]</h4>

<p>
There exist several overloaded functions named <code>make_zoned</code>
which serve as factory functions for <code>zoned_time&lt;Duration&gt;</code> and
will deduce the correct <code>Duration</code> from the argument list.  In every
case the correct return type is
<code>zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;</code>.
</p>

<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(sys_time&lt;Duration&gt; tp)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{tp}</code>.
</p>
</blockquote>


<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(const time_zone* zone, local_time&lt;Duration&gt; tp)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{zone, tp}</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(const string&amp; name, local_time&lt;Duration&gt; tp)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{name, tp}</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(const time_zone* zone, local_time&lt;Duration&gt; tp, choose c)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{zone, tp, c}</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(const string&amp; name, local_time&lt;Duration&gt; tp, choose c)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{name, tp, c}</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(const time_zone* zone, const zoned_time&lt;Duration&gt;&amp; zt)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{zone, zt}</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(const string&amp; name, const zoned_time&lt;Duration&gt;&amp; zt)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{name, zt}</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(const time_zone* zone, const zoned_time&lt;Duration&gt;&amp; zt, choose c)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{zone, zt, c}</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(const string&amp; name, const zoned_time&lt;Duration&gt;&amp; zt, choose c)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{name, zt, c}</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(const time_zone* zone, const sys_time&lt;Duration&gt;&amp; st)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{zone, st}</code>.
</p>
</blockquote>

<pre>
template &lt;class Duration&gt;
zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;
make_zoned(const string&amp; name, const sys_time&lt;Duration&gt;&amp; st)
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>{name, st}</code>.
</p>
</blockquote>

<h4>20.17.10.7 Formatting [time.timezone.format]</h4>

<pre>
template &lt;class charT, class traits, class Duration&gt;
basic_string&lt;class charT, class traits&gt;
format(const locale&amp; loc, basic_string&lt;class charT, class traits&gt; format,
       const local_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class traits, class Duration&gt;
basic_string&lt;class charT, class traits&gt;
format(basic_string&lt;class charT, class traits&gt; format, const local_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class traits, class Duration&gt;
basic_string&lt;class charT, class traits&gt;
format(const locale&amp; loc, basic_string&lt;class charT, class traits&gt; format,
       const zoned_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class traits, class Duration&gt;
basic_string&lt;class charT, class traits&gt;
format(basic_string&lt;class charT, class traits&gt; format, const zoned_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class traits, class Duration&gt;
basic_string&lt;class charT, class traits&gt;
format(const locale&amp; loc, basic_string&lt;class charT, class traits&gt; format,
       const sys_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class traits, class Duration&gt;
basic_string&lt;class charT, class traits&gt;
format(basic_string&lt;class charT, class traits&gt; format, const sys_time&lt;Duration&gt;&amp; tp);

// const charT* formats

template &lt;class charT, class Duration&gt;
basic_string&lt;class charT&gt;
format(const locale&amp; loc, const charT* format, const local_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class Duration&gt;
basic_string&lt;class charT&gt;
format(const charT* format, const local_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class Duration&gt;
basic_string&lt;class charT&gt;
format(const locale&amp; loc, const charT* format, const zoned_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class Duration&gt;
basic_string&lt;class charT&gt;
format(const charT* format, const zoned_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class Duration&gt;
basic_string&lt;class charT&gt;
format(const locale&amp; loc, const charT* format, const sys_time&lt;Duration&gt;&amp; tp);

template &lt;class charT, class Duration&gt;
basic_string&lt;class charT&gt;
format(const charT* format, const sys_time&lt;Duration&gt;&amp; tp);
</pre>
<blockquote>
<p>
<i>Effects:</i>  These functions create a formatted time stamp using the
arguments, returning the result in a <code>string</code>.
</p>
<blockquote>
<p>
If a <code>locale</code> is passed in, then that <code>locale</code> is used for
any formatting that requires a <code>locale</code>.  If no <code>locale</code>
is passed in, then if a <code>locale</code> is required for formatting, a
default constructed <code>locale</code> will be used (which makes a copy of the
global <code>locale</code>).
</p>
<p>
The <code>format</code> string follows the rules as specified for
<code>time_put</code> with the following exceptions:
</p>
<ul>
<li><p>
If <code>%S</code> or <code>%T</code> appears in the <code>format</code> string
and the argument <code>tp</code> has precision finer than seconds, then seconds
are formatted as a decimal floating point number with a fixed format and a
precision matching that of the precision of <code>tp</code>.  The character for
the decimal point is localized according to the <code>locale</code>.
</p></li>

<li><p>
If <code>%z</code> appears in the format, the behavior depends on the type of
<code>tp</code>:
</p>
<ul>
<li>
<code>local_time</code>: An exception of type <code>runtime_error</code> is thrown.
</li>
<li>
<code>zoned_time</code>: The offset associated with <code>tp.get_time_zone()</code> is
used.
</li>
<li>
<code>sys_time</code>: <code>"+0000"</code> is used.
</li>
</ul>
<p>
In any event the offset is formatted as <code>+/-hhmm</code> unless the flag is
modified as <code>%Ez</code> or <code>%Oz</code> in which case the offset is
formatted as <code>+/-hh:mm</code>.  If the offset is not an integral number of
minutes, it is truncated towards zero to an integral number of minutes.
</p>
</li>

<li><p>
If <code>%Z</code> appears in the format, the behavior depends on the type of
<code>tp</code>:
</p>
<ul>
<li>
<code>local_time</code>: An exception of type <code>runtime_error</code> is thrown.
</li>
<li>
<code>zoned_time</code>: The abbreviation associated with
<code>tp.get_time_zone()</code> is used.
</li>
<li>
<code>sys_time</code>: <code>"UTC"</code> is used.
</li>
</ul>
</li>

</ul>

<p>
For the overloads taking a <code>zoned_time</code> it is the value returned by
<code>tz.get_local_time()</code> that is formatted.
</p>
</blockquote>

<p>
<i>Returns:</i> The formatted string.
</p>

</blockquote>

<h4>20.17.10.8 Parsing [time.timezone.parse]</h4>

<p>
One can parse in a <code>sys_time&lt;Duration&gt;</code> or a
<code>local_time&lt;Duration&gt;</code>.  Optionally, one can also pass in a reference
to a <code>string</code> in order to capture the time zone abbreviation, or one
can pass in a reference to a <code>minutes</code> to capture a time zone
UTC offset (formatted as specified by <code>%z</code> or its modified variants),
or one can pass in both in either order.
</p>

<pre>
template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const basic_string&lt;charT, traits&gt;&amp; format, sys_time&lt;Duration&gt;&amp; tp);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const basic_string&lt;charT, traits&gt;&amp; format, sys_time&lt;Duration&gt;&amp; tp,
      basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const basic_string&lt;charT, traits&gt;&amp; format, sys_time&lt;Duration&gt;&amp; tp,
      minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const basic_string&lt;charT, traits&gt;&amp; format, sys_time&lt;Duration&gt;&amp; tp,
      basic_string&lt;charT, traits&gt;&amp; abbrev, minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const basic_string&lt;charT, traits&gt;&amp; format, sys_time&lt;Duration&gt;&amp; tp,
      minutes&amp; offset, basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const basic_string&lt;charT, traits&gt;&amp; format, local_time&lt;Duration&gt;&amp; tp);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const basic_string&lt;charT, traits&gt;&amp; format, local_time&lt;Duration&gt;&amp; tp,
      basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const basic_string&lt;charT, traits&gt;&amp; format, local_time&lt;Duration&gt;&amp; tp,
      minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const basic_string&lt;charT, traits&gt;&amp; format, local_time&lt;Duration&gt;&amp; tp,
      basic_string&lt;charT, traits&gt;&amp; abbrev, minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const basic_string&lt;charT, traits&gt;&amp; format, local_time&lt;Duration&gt;&amp; tp,
      minutes&amp; offset, basic_string&lt;charT, traits&gt;&amp; abbrev);

// const charT* formats

template &lt;class Duration, class charT&gt;
<i>unspecified</i>
parse(const charT* format, sys_time&lt;Duration&gt;&amp; tp);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const charT* format, sys_time&lt;Duration&gt;&amp; tp,
      basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT&gt;
<i>unspecified</i>
parse(const charT* format, sys_time&lt;Duration&gt;&amp; tp,
      minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const charT* format, sys_time&lt;Duration&gt;&amp; tp,
      basic_string&lt;charT, traits&gt;&amp; abbrev, minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const charT* format, sys_time&lt;Duration&gt;&amp; tp,
      minutes&amp; offset, basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT&gt;
<i>unspecified</i>
parse(const charT* format, local_time&lt;Duration&gt;&amp; tp);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const charT* format, local_time&lt;Duration&gt;&amp; tp,
      basic_string&lt;charT, traits&gt;&amp; abbrev);

template &lt;class Duration, class charT&gt;
<i>unspecified</i>
parse(const charT* format, local_time&lt;Duration&gt;&amp; tp,
      minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const charT* format, local_time&lt;Duration&gt;&amp; tp,
      basic_string&lt;charT, traits&gt;&amp; abbrev, minutes&amp; offset);

template &lt;class Duration, class charT, class traits&gt;
<i>unspecified</i>
parse(const charT* format, local_time&lt;Duration&gt;&amp; tp,
      minutes&amp; offset, basic_string&lt;charT, traits&gt;&amp; abbrev);
</pre>
<blockquote>
<p>
<i>Returns:</i> These functions return an object of unspecified type with a
stream extraction operation that behaves as a formatted input function and
attempts to parse a <code>time_point</code> out of the input stream
<code>is</code> according to <code>format</code>.
</p>
<blockquote>
<p>
The <code>format</code> string follows the rules as specified for <code>time_get</code>
with the following exceptions:
</p>
<ul>
<li><p>
If <code>%F</code> appears in the format string it is interpreted as
<code>%Y-%m-%d</code>.
</p></li>

<li><p>
If <code>%S</code> or <code>%T</code> appears in the <code>format</code> string
and the argument <code>tp</code> has precision finer than seconds, then the
seconds are parsed as a <code>double</code>, and if that parse is successful
contributes to the time stamp as if
<code>round&lt;Duration&gt;(duration&lt;double&gt;{s})</code> where
<code>s</code> is a local variable holding the parsed <code>double</code>.
</p></li>

<li><p>
If <code>%z</code> appears in the <code>format</code> string and an offset is
successfully parsed, the overloads taking <code>sys_time</code> interprets the
parsed time as a local time and subtracts the offset prior to assigning the
value to <code>tp</code>, resulting in a value of <code>tp</code> representing a
UTC timestamp.  The overloads taking <code>local_time</code> require a valid
parse of the offset, but then ignore the offset in assigning a value to the
<code>local_time&lt;Duration&gt;&amp; tp</code>.  If <code>offset</code> is
passed in, on successful parse it will hold the value represented by
<code>%z</code> if present, or will be assigned <code>0min</code> if
<code>%z</code> is not present.
</p>
<p>
The format of the offset is <code>+/-hhmm</code>. The leading plus or minus sign
is required. If the format string was modified (i.e. <code>%Ez</code> or
<code>%Oz</code>), a colon is required between hours and minutes, and the
leading hours digit is optional: <code>+/-[h]h:mm</code>.
</p></li>

<li><p>
If <code>%Z</code> appears in the <code>format</code> string then an
abbreviation is required in that position for a successful parse.  The
abbreviation will be parsed as a <code>string</code> (delimited by white
space).  The parsed abbreviation does not have to be a valid time zone
abbreviation, and has no impact on the value parsed into <code>tp</code>.  Using
the overloads that take a <code>string&amp;</code> one can discover what
that parsed abbreviation is.  On successful parse, <code>abbrev</code> will be
assigned the value represented by <code>%Z</code> if present, or assigned the
empty string if <code>%Z</code> is not present.
</p></li>
</ul>
</blockquote>
<p>
[<i>Example:</i>
</p>
<blockquote><pre>
sys_seconds tp;
minutes offset;
istringstream in("2016-10-02 22:54:00 -0400");
in &gt;&gt; parse("%F %T %z", tp, offset);
// tp == 1475463240s
// offset == -240min
</pre></blockquote>
<p>
&mdash; <i>end example</i>]
</p>
</blockquote>

<h4>20.17.10.10 class <code>leap</code> [time.timezone.leap]</h4>

<pre>
class leap
{
public:
    leap(const leap&amp;)            = default;
    leap&amp; operator=(const leap&amp;) = default;
    
    // Undocumented constructors

    sys_seconds date() const;
};

bool operator==(const leap&amp; x, const leap&amp; y);
bool operator!=(const leap&amp; x, const leap&amp; y);
bool operator&lt; (const leap&amp; x, const leap&amp; y);
bool operator&gt; (const leap&amp; x, const leap&amp; y);
bool operator&lt;=(const leap&amp; x, const leap&amp; y);
bool operator&gt;=(const leap&amp; x, const leap&amp; y);

template &lt;class Duration&gt; bool operator==(const const leap&amp;         x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator==(const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
template &lt;class Duration&gt; bool operator!=(const leap&amp;               x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator!=(const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
template &lt;class Duration&gt; bool operator&lt; (const leap&amp;               x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator&lt; (const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
template &lt;class Duration&gt; bool operator&gt; (const leap&amp;               x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator&gt; (const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
template &lt;class Duration&gt; bool operator&lt;=(const leap&amp;               x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator&lt;=(const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
template &lt;class Duration&gt; bool operator&gt;=(const leap&amp;               x, const sys_time&lt;Duration&gt;&amp; y);
template &lt;class Duration&gt; bool operator&gt;=(const sys_time&lt;Duration&gt;&amp; x, const leap&amp;               y);
</pre>

<p>
<code>leap</code> is a copyable class that is constructed and stored in the time zone
database when initialized.  You can explicitly convert it to a <code>sys_seconds</code>
with the member function <code>date()</code> and that will be the date of the leap second
insertion.  <code>leap</code> is equality and less-than comparable, both with itself, and
with <code>sys_time&lt;Duration&gt;</code>.
</p>

<h4>20.17.10.11 class <code>link</code> [time.timezone.link]</h4>

<pre>
class link
{
public:
    link(const link&amp;)            = default;
    link&amp; operator=(const link&amp;) = default;

    // Undocumented constructors

    const string&amp; name()   const;
    const string&amp; target() const;
};

bool operator==(const link&amp; x, const link&amp; y);
bool operator!=(const link&amp; x, const link&amp; y);
bool operator&lt; (const link&amp; x, const link&amp; y);
bool operator&gt; (const link&amp; x, const link&amp; y);
bool operator&lt;=(const link&amp; x, const link&amp; y);
bool operator&gt;=(const link&amp; x, const link&amp; y);
</pre>
<p>
A <code>link</code> is an alternative name for a <code>time_zone</code>.  The alternative
name is <code>name()</code>.  The name of the <code>time_zone</code> for which this is
an alternative name is <code>target()</code>.  <code>link</code>s will be constructed
for you when the time zone database is initialized.
</p>

<a name="Acknowledgements"></a><h2>Acknowledgements</h2>

<p>
A database parser is nothing without its database.  I would like to thank the founding
contributor of the <a href="http://www.iana.org/time-zones">IANA Time Zone Database</a>
Arthur David Olson.  I would also like to thank the entire group of people who continually
maintain it, and especially the IESG-designated TZ Coordinator, Paul Eggert.  Without the
work of these people, this software would have no data to parse.
</p>
<p>
I would also like to thank Jiangang Zhuang and Bjarne Stroustrup for invaluable
feedback for the timezone portion of this library, which ended up also
influencing the date.h library.  Thanks also to Jonathan Wakely for agreeing to
present this paper in Oulu for me.
</p>
<p>
And I would also especially like to thank contributors to this library:  gmcode,
Ivan Pizhenko, tomy2105 and Ville Voutilainen.
</p>

<a name="References"></a><h2>References</h2>

<ol>
<li>
<p>
N. Dershowitz and E. Reingold, <i>Calendrical Calculations 3rd ed.</i>, Cambridge
University Press 2008.
</p>
</li>
</ol>

</body>
</html>
